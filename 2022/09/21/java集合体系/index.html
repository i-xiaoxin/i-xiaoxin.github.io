

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/tab.png">
  <link rel="icon" href="/img/tab.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="xiaoxinlore">
  <meta name="keywords" content="java">
  
    <meta name="description" content="数组存在问题: 数组长度固定  存入的类型只能是一种(数据单一)  数组是线性结构，增删效率低   假设现在有一个情景需求，统计一个学校的学生,如果使用数组则需要固定长度,而一旦固定了之后,加入学校开除学生了则不能减少数组长度,同样如果学校中途又来了学生也没办法添加;所以数组是">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合体系">
<meta property="og:url" content="https://github.com/i-xiaoxin/2022/09/21/java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB/index.html">
<meta property="og:site_name" content="xiaoxinlore">
<meta property="og:description" content="数组存在问题: 数组长度固定  存入的类型只能是一种(数据单一)  数组是线性结构，增删效率低   假设现在有一个情景需求，统计一个学校的学生,如果使用数组则需要固定长度,而一旦固定了之后,加入学校开除学生了则不能减少数组长度,同样如果学校中途又来了学生也没办法添加;所以数组是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.shields.io/github/stars/i-xiaoxin/i-xiaoxin.github.io?affiliations=OWNER&color=success&logo=github&style=plastic">
<meta property="og:image" content="https://img.shields.io/github/followers/i-xiaoxin?color=success&logo=github&style=plastic">
<meta property="og:image" content="https://img.shields.io/github/languages/top/i-xiaoxin/i-xiaoxin.github.io?color=success&label=java&logo=github&style=plastic">
<meta property="og:image" content="https://readme-typing-svg.demolab.com/?font=Ma+Shan+Zheng&pause=1000&width=435&lines=%F0%9F%9A%80%E5%AE%9D%E5%89%91%E9%94%8B%E4%BB%8E%E7%A3%A8%E7%A0%BA%E5%87%BA%EF%BC%8C%E6%A2%85%E8%8A%B1%E9%A6%99%E8%87%AA%E8%8B%A6%E5%AF%92%E6%9D%A5">
<meta property="og:image" content="https://raw.githubusercontent.com/i-xiaoxin/image/master/09.png">
<meta property="og:image" content="https://raw.githubusercontent.com/i-xiaoxin/image/master/10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/i-xiaoxin/image/master/11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/i-xiaoxin/image/master/12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/i-xiaoxin/image/master/13.png">
<meta property="og:image" content="https://raw.githubusercontent.com/i-xiaoxin/image/master/14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/i-xiaoxin/image/master/15.png">
<meta property="article:published_time" content="2022-09-21T10:12:02.000Z">
<meta property="article:modified_time" content="2022-10-27T02:22:24.388Z">
<meta property="article:author" content="xiaoxinlore">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.shields.io/github/stars/i-xiaoxin/i-xiaoxin.github.io?affiliations=OWNER&color=success&logo=github&style=plastic">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java集合体系 - xiaoxinlore</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"github.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>xiaoxinlore</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/article1.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java集合体系"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-21 18:12" pubdate>
          2022年9月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          69k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          572 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java集合体系</h1>
            
            
              <div class="markdown-body">
                
                <div align="center">
    <a title="Github Total Stars" target="_blank" href="https://i-xiaoxin.github.io">
        <img src="https://img.shields.io/github/stars/i-xiaoxin/i-xiaoxin.github.io?affiliations=OWNER&color=success&logo=github&style=plastic" srcset="/img/loading.gif" lazyload />
    </a>
    <a title="Github Followers" target="_blank" href="https://i-xiaoxin.github.io">
        <img src="https://img.shields.io/github/followers/i-xiaoxin?color=success&logo=github&style=plastic" srcset="/img/loading.gif" lazyload />
    </a>
    <a title="Target " target="_blank" href="https://i-xiaoxin.github.io">
        <img src="https://img.shields.io/github/languages/top/i-xiaoxin/i-xiaoxin.github.io?color=success&label=java&logo=github&style=plastic" srcset="/img/loading.gif" lazyload />
    </a>
</div>
<div align="center"><a target="_blank" rel="noopener" href="https://i-xiaoxin.github.io/"><img src="https://readme-typing-svg.demolab.com?font=Ma+Shan+Zheng&pause=1000&width=435&lines=%F0%9F%9A%80%E5%AE%9D%E5%89%91%E9%94%8B%E4%BB%8E%E7%A3%A8%E7%A0%BA%E5%87%BA%EF%BC%8C%E6%A2%85%E8%8A%B1%E9%A6%99%E8%87%AA%E8%8B%A6%E5%AF%92%E6%9D%A5" srcset="/img/loading.gif" lazyload alt="Typing SVG" /></a></div>

<h3 id="数组存在问题"><a href="#数组存在问题" class="headerlink" title="数组存在问题:"></a>数组存在问题:</h3><ul>
<li><p>数组长度固定</p>
</li>
<li><p>存入的类型只能是一种(数据单一)</p>
</li>
<li><p>数组是线性结构，增删效率低</p>
</li>
</ul>
<p>假设现在有一个情景需求，统计一个学校的学生,如果使用数组则需要固定长度,而一旦固定了之后,加入学校开除学生了则不能减少数组长度,同样如果学校中途又来了学生也没办法添加;所以数组是无法解决这个问题的,因为学生的统计是不固定的,有可能会增加也有可能会减少；所以出现了集合</p>
<p>集合的出现就是为了解决数组的问题,所以能够确定一点就是集合更加的强大;<strong>集合存储数据必须是引用数据类型</strong></p>
<h3 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h3><blockquote>
<p>Collection接口体系</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/i-xiaoxin/image/master/09.png" srcset="/img/loading.gif" lazyload alt="Collection接口体系"></p>
<blockquote>
<p>Map接口体系</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/i-xiaoxin/image/master/10.png" srcset="/img/loading.gif" lazyload alt="Map接口体系"></p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ul>
<li><p><code>boolean add(E e)</code>:向集合中添加元素</p>
</li>
<li><p><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>:向集合中添加一个集合元素</p>
</li>
<li><p><code>boolean contains(Object o)</code>:检测集合中是否包含某个元素</p>
</li>
<li><p><code>boolean containsAll(Collection&lt;?&gt; c)</code>:检测集合中是否包含另一个集合中的元素</p>
</li>
<li><p><code>boolean remove(Object o)</code>:从集合中移除指定数据(对象)</p>
</li>
<li><p><code>boolean removeAll(Collection&lt;?&gt; c)</code>:移除此集合的所有也包含在指定集合中的元素</p>
</li>
<li><div>
  <hr>
  <script src="https://unpkg.com/@waline/client@v2/dist/waline.js"></script> 
  <link
    rel="stylesheet"
    href="https://unpkg.com/@waline/client@v2/dist/waline.css"
  />
  <div id="waline"></div>
    <script>
      Waline({
        el: '#waline',
        serverURL: 'https://vercel-project-4d7haxk1c-i-xiaoxin.vercel.app',
      });
    </script>
</li>
<li><p><code>int size()</code>:返回集合中的元素数量</p>
</li>
<li><p><code>boolean isEmpty()</code>:判断集合是否为空</p>
</li>
<li><p><code>Object[] toArray()</code>:将集合转为数组</p>
</li>
<li><p><code>void clear()</code>:清空集合内元素</p>
</li>
<li><p><code>Iterator&lt;E&gt; iterator()</code>:返回集合迭代器元素,用于遍历集合中的所有元素</p>
<p>  代码案例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 由于Collection是接口所以无法直接创建对象,所以使用其子类创建(ArrayList)</span><br>        <span class="hljs-comment">// 以多态方式创建Collection接口集合,并且只能使用Collection接口中的方法</span><br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">collection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 1. `boolean add(E e)`:向集合中添加元素</span><br>        collection.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        collection.add(<span class="hljs-number">18</span>);<br>        collection.add(<span class="hljs-number">185.2</span>);<br>        collection.add(<span class="hljs-string">&quot;男&quot;</span>);<br>        System.out.println(collection);<br>        <span class="hljs-comment">// 2. `boolean addAll(Collection&lt;? extends E&gt; c)`:向集合中添加一个集合元素</span><br>        <span class="hljs-type">Collection</span> <span class="hljs-variable">collection1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        collection.add(<span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        collection.add(<span class="hljs-number">19</span>);<br>        collection.add(<span class="hljs-number">182.2</span>);<br>        collection.add(<span class="hljs-string">&quot;男&quot;</span>);<br>        collection.addAll(collection1);<br>        System.out.println(collection);<br>        <span class="hljs-comment">// 3. `boolean contains(Object o)`:检测集合中是否包含某个元素</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContains</span> <span class="hljs-operator">=</span> collection.contains(<span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        System.out.println(isContains);<br>        isContains = collection.contains(<span class="hljs-string">&quot;吴彦祖1&quot;</span>);<br>        System.out.println(isContains);<br>        <span class="hljs-comment">// 4. `boolean containsAll(Collection&lt;?&gt; c)`:检测集合中是否包含另一个集合中的元素</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContainsAll</span> <span class="hljs-operator">=</span> collection.containsAll(collection1);<br>        System.out.println(isContainsAll);<br>        <span class="hljs-comment">// collection1中再添加一条数据</span><br>        collection1.add(<span class="hljs-string">&quot;帅&quot;</span>);<br>        isContainsAll = collection.containsAll(collection1);<br>        System.out.println(isContainsAll);<br>        <span class="hljs-comment">// 5.  `boolean remove(Object o)`:从集合中移除指定数据(对象)</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isRemove</span> <span class="hljs-operator">=</span> collection.remove(<span class="hljs-string">&quot;帅&quot;</span>);<br>        System.out.println(isRemove);<br>        System.out.println(collection);<br>        isRemove = collection.remove(<span class="hljs-string">&quot;男&quot;</span>);<br>        System.out.println(isRemove);<br>        System.out.println(collection);<br>        <span class="hljs-comment">// 6. `boolean removeAll(Collection&lt;?&gt; c)`:移除此集合的所有也包含在指定集合中的元素</span><br>        <span class="hljs-comment">// 7. `boolean retainAll(Collection&lt;?&gt; c)`:移除刺激和的所有不包含在指定集合中的元素(移除非相同的元素,非交集元素)</span><br>        <span class="hljs-comment">// 8. `int size()`:返回集合中的元素数量</span><br>        System.out.println(collection.size());<br>        <span class="hljs-comment">// 9. `boolean isEmpty()`:判断集合是否为空</span><br>        System.out.println(collection.isEmpty());<br>        <span class="hljs-comment">// 10. `Object[] toArray()`:将集合转为数组</span><br>        <span class="hljs-comment">// 11. `void clear()`:清空集合内元素</span><br>        collection.clear();<br>        System.out.println(collection);<br>        System.out.println(collection.isEmpty());<br>        <span class="hljs-comment">// 12. `Iterator&lt;E&gt; iterator()`:返回集合迭代器元素,用于遍历集合中的所有元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul>
<li><code>boolean add(E e)</code>:向List集合中添加元素<code>常用</code></li>
<li><code>void add(int index, E element)</code>:向List集合中指定位置添加元素</li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>:将指定集合中的所有元素追加到此集合的末尾</li>
<li><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>:将指定集合中的所有元素追加到此集合的指定位置</li>
<li><code>boolean contains(Object o)</code>:检测此集合中是否包含指定元素<code>常用</code></li>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code>:检测集合中是否包含另一个集合中的元素</li>
<li><code>E get(int index)</code>:获取集合中指定下标索引的元素并返回<code>常用</code></li>
<li><code>E set(int index, E element)</code>:修改集合中指定下标索引的元素</li>
<li><code>int indexOf(Object o)</code>:在集合中查找元素如果存在则返回此元素的下标索引(返回第一次发现的下标索引)</li>
<li><code>int lastIndexOf(Object o)</code>:在集合中查找元素如果存在则返回此元素的下标索引(返回最后一次发现的下标索引)</li>
<li><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code>:切割集合,指定起始位置和结束位置</li>
<li><code>ListIterator&lt;E&gt; listIterator()</code>:返回List接口迭代器</li>
<li><code>int size()</code>:返回集合中的元素数量<code>常用</code></li>
<li><code>boolean isEmpty()</code>:判断集合是否为空<code>常用</code></li>
<li><code>Object[] toArray()</code>:将集合转为数组</li>
<li><code>void clear()</code>:清空集合内元素</li>
<li><code>Iterator&lt;E&gt; iterator()</code>:返回集合迭代器元素,用于遍历集合中的所有元素</li>
</ul>
<p>代码案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用多态方式创建List接口对象--&gt;使用其子类ArrayList</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 1. `boolean add(E e)`:向List集合中添加元素`常用`</span><br>        list.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        list.add(<span class="hljs-number">18</span>);<br>        list.add(<span class="hljs-string">&quot;男神&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 2. `void add(int index, E element)`:向List集合中指定位置添加元素</span><br>        list.add(<span class="hljs-number">2</span>, <span class="hljs-number">185.3</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 3. `boolean addAll(Collection&lt;? extends E&gt; c)`:将指定集合中的所有元素追加到此集合的末尾</span><br>        <span class="hljs-comment">// 4. `boolean addAll(int index, Collection&lt;? extends E&gt; c)`:将指定集合中的所有元素追加到此集合的指定位置</span><br>        <span class="hljs-comment">// 5. `boolean contains(Object o)`:检测此集合中是否包含指定元素`常用`</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContains</span> <span class="hljs-operator">=</span> list.contains(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(isContains);<br>        isContains = list.contains(<span class="hljs-string">&quot;彭于晏1&quot;</span>);<br>        System.out.println(isContains);<br>        <span class="hljs-comment">// 6. `boolean containsAll(Collection&lt;?&gt; c)`:检测集合中是否包含另一个集合中的元素</span><br>        <span class="hljs-comment">// 7. `E get(int index)`:获取集合中指定下标索引的元素并返回`常用`</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>        System.out.println(o);<br>        <span class="hljs-comment">// 如果调用超出范围则报异常--&gt;IndexOutOfBoundsException: Index: 100, Size: 4</span><br>        <span class="hljs-comment">// Object o1 = list.get(100);</span><br>        <span class="hljs-comment">// System.out.println(o1);</span><br>        <span class="hljs-comment">// 8. `E set(int index, E element)`:修改集合中指定下标索引的元素</span><br>        <span class="hljs-comment">// 返回的结果是修改前的内容</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">set</span> <span class="hljs-operator">=</span> list.set(<span class="hljs-number">2</span>, <span class="hljs-number">185.0</span>);<br>        System.out.println(set);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 9. `int indexOf(Object o)`:在集合中查找元素如果存在则返回此元素的下标索引(返回第一次发现的下标索引)</span><br>        <span class="hljs-comment">// 在集合中多添加一些数据</span><br>        list.add(<span class="hljs-string">&quot;男&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;男神&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> list.indexOf(<span class="hljs-string">&quot;男神&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;返回下标:&quot;</span> + index);<br>        <span class="hljs-comment">// 如果不存在则返回-1</span><br>        index = list.indexOf(<span class="hljs-string">&quot;男神123&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;返回下标:&quot;</span> + index);<br>        <span class="hljs-comment">// 10. `int lastIndexOf(Object o)`:在集合中查找元素如果存在则返回此元素的下标索引(返回最后一次发现的下标索引)</span><br>        index = list.lastIndexOf(<span class="hljs-string">&quot;男神&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;返回下标:&quot;</span> + index);<br>        <span class="hljs-comment">// 如果不存在则返回-1</span><br>        index = list.lastIndexOf(<span class="hljs-string">&quot;男神123&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;返回下标:&quot;</span> + index);<br>        <span class="hljs-comment">// 11. `List&lt;E&gt; subList(int fromIndex, int toIndex)`:切割集合,指定起始位置和结束位置</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">subList</span> <span class="hljs-operator">=</span> list.subList(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>        System.out.println(subList);<br>        <span class="hljs-comment">// 12. `ListIterator&lt;E&gt; listIterator()`:返回List接口迭代器</span><br>        <span class="hljs-comment">// 13. `int size()`:返回集合中的元素数量`常用`</span><br>        <span class="hljs-comment">// 14. `boolean isEmpty()`:判断集合是否为空`常用`</span><br>        <span class="hljs-comment">// 15. `Object[] toArray()`:将集合转为数组</span><br>        <span class="hljs-comment">// 16. `void clear()`:清空集合内元素</span><br>        <span class="hljs-comment">// 17. `Iterator&lt;E&gt; iterator()`:返回集合迭代器元素,用于遍历集合中的所有元素</span><br><br><br>        System.out.println(<span class="hljs-string">&quot;========================================&quot;</span>);<br>        <span class="hljs-comment">// 使用迭代器</span><br>        <span class="hljs-comment">// `Iterator&lt;E&gt; iterator()`:返回集合迭代器元素,用于遍历集合中的所有元素</span><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">iterator</span> <span class="hljs-operator">=</span> list.iterator();<br>        <span class="hljs-comment">// 迭代器方法boolean hasNext();--&gt;判断iterator中是否还有可迭代的元素</span><br>        <span class="hljs-comment">// 迭代器方法E next();--&gt;输出迭代器中的元素--&gt;类似于指针每次调用都会向后移</span><br>        <span class="hljs-comment">// next如果超出范围则报错--&gt;NoSuchElementException</span><br>        <span class="hljs-comment">// 将next指针指向下一个元素</span><br>        <span class="hljs-comment">/*Object next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);</span><br><span class="hljs-comment">        // 将next指针指向下一个元素</span><br><span class="hljs-comment">        next = iterator.next();</span><br><span class="hljs-comment">        System.out.println(next);*/</span><br>        <span class="hljs-comment">// iterator.hasNext()验证是否有下一条数据</span><br>        <span class="hljs-comment">/*boolean b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);</span><br><span class="hljs-comment">        iterator.next();</span><br><span class="hljs-comment">        b = iterator.hasNext();</span><br><span class="hljs-comment">        System.out.println(b);*/</span><br>        <span class="hljs-comment">// 使用while循环</span><br>        <span class="hljs-comment">// iterator.hasNext()判断是否存在元素</span><br>        <span class="hljs-comment">// list.clear();</span><br>        <span class="hljs-comment">// iterator = list.iterator();</span><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-comment">// 将next指针指向下一条数据</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-comment">// 输出结果</span><br>            System.out.println(next);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;========================================&quot;</span>);<br>        <span class="hljs-comment">// for循环遍历与上面的iterator迭代器相同都是遍历</span><br>        <span class="hljs-keyword">for</span> (Object o1 : list) &#123;<br>            System.out.println(o1);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;========================================&quot;</span>);<br>        <span class="hljs-comment">// `ListIterator&lt;E&gt; listIterator()`:返回List接口迭代器</span><br>        <span class="hljs-type">ListIterator</span> <span class="hljs-variable">listIterator</span> <span class="hljs-operator">=</span> list.listIterator();<br>        <span class="hljs-keyword">while</span> (listIterator.hasNext()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> listIterator.next();<br>            System.out.println(next);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="List接口之实现类ArrayList"><a href="#List接口之实现类ArrayList" class="headerlink" title="List接口之实现类ArrayList"></a>List接口之实现类ArrayList</h3><h4 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h4><blockquote>
<p>ArrayList–&gt;仅从名字看是数组集合–&gt;ArrayList其底层是数组实现的,但是通过某些手段实现了可变长度的数组(动态数组),其容量可以自动增长动态增加容量<br>官方解释:</p>
<p>List接口的可调整大小的数组实现(ArrayList是List接口的实现类,并且是动态数组大小)。实现了List接口的所有操作，并允许添加所有元素，包括null(但不建议添加null) 。除了实现List接口之外，该类还提供了一些自己的方法用来实现动态数组大小的方法;</p>
<p><code>(注意:ArrayList类与Vector类的方法相同,不同之处在于ArrayList是线程不安全,而Vector是线程安全)</code></p>
</blockquote>
<h4 id="ArrayList中的底层实现源码"><a href="#ArrayList中的底层实现源码" class="headerlink" title="ArrayList中的底层实现源码"></a>ArrayList中的底层实现源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;<br>    <span class="hljs-comment">// ArrayList底层实现是使用数组实现的</span><br>    <span class="hljs-comment">// transient--&gt;(瞬时/瞬态/短暂的)--&gt;如果通过网络传输此对象或向文件中写入此对象则不保留的字段(此字段不传输的内容)</span><br>    <span class="hljs-comment">// 通过transient关键字修饰的只能在Java中使用,不能传输(例如写入文件和网络传输)</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ArrayList添加方法"><a href="#ArrayList添加方法" class="headerlink" title="ArrayList添加方法"></a>ArrayList添加方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayList集合的元素数量,与数组无关,因为是成员变量所以默认是0</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><span class="hljs-comment">// 向集合末尾添加元素</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 判断当前集合的大小,size是当前添加的元素数量,如果没有添加则默认是0</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 此方法是add添加时调用的,用于判断集合空间的大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 确保显式容量,并且参数是计算容量calculateCapacity()方法,用于计算当前容量</span><br>    <span class="hljs-comment">// calculateCapacity()中的参数elementData是数组,minCapacity传入的最小容量</span><br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><span class="hljs-comment">// 此方法是ensureExplicitCapacity中内部调用的,作用是计算容器的容量大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 使用传入的数组容器与默认数组容器使用==判断,判断是否相同的内存地址</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-comment">// 返回Math数学类中的max方法计算出的大小</span><br>        <span class="hljs-comment">// 如果DEFAULT_CAPACITY大则返回DEFAULT_CAPACITY</span><br>        <span class="hljs-comment">// 如果minCapacity大则返回minCapacity</span><br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">// 直接返回最小空间</span><br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><span class="hljs-comment">// 确保内部容量大小,minCapacity空间是从--&gt;calculateCapacity方法计算而来</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 集合修改的次数(不用管)</span><br>    modCount++;<br>    <span class="hljs-comment">// 使用传入的最小空间minCapacity减去数组长度elementData.length,如果大于0则空间溢出,</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 如果没有空间则进入继续计算,设置elementData数组的空间</span><br>        <span class="hljs-comment">// 调用grow方法增加数组长度</span><br>        grow(minCapacity);<br>&#125;<br><span class="hljs-comment">// 动态增加数组长度--&gt;数组长度不足时会调用的方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 第一步将数组长度赋值给old空间(oldCapacity)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 设置新空间(newCapacity) = oldCapacity(老空间)+(oldCapacity&gt;&gt;1)老空间右移一位,代表空间除2</span><br>    <span class="hljs-comment">// 为什么计算空间时要加这么大的空间,原因是你都调用了并且能加到这个数值代表你是常用,所以不可能一直给你默认一个数值</span><br>    <span class="hljs-comment">// 新数组空间的计算结果其实就是原空间的1.5倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 新空间减去传入的最小空间如果小于0则代表计算出来空间太小</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 如果小了则将最小空间重新赋值给新空间</span><br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">// 如果新空间减去最大空间(MAX_ARRAY_SIZE=2147483639)</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 如果大于则将新空间重新计算一个数值并赋值</span><br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// 最终的扩容,将原数组与新空间通过Arrays.copyOf()方法拷贝至当前数组中,完成了数组的扩容</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/i-xiaoxin/image/master/11.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="ArrayList获取方法"><a href="#ArrayList获取方法" class="headerlink" title="ArrayList获取方法"></a>ArrayList获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取下标索引元素方法</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 验证输入的index是否超出范围,超出则抛异常</span><br>    rangeCheck(index);<br>    <span class="hljs-comment">// 返回index小表索引的元素</span><br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><span class="hljs-comment">// 获取index下标索引元素的方法</span><br>E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 返回数组当前index下标元素;例如:String[]strs = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;--&gt;strs[1]</span><br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ArrayList修改方法"><a href="#ArrayList修改方法" class="headerlink" title="ArrayList修改方法"></a>ArrayList修改方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改方法</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 验证输入的index是否超出范围,超出则抛异常</span><br>    rangeCheck(index);<br>    <span class="hljs-comment">// 获取当前数组index下标索引的元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <span class="hljs-comment">// 将当前index下标索引数据修改为传入的数据</span><br>    elementData[index] = element;<br>    <span class="hljs-comment">// 返回修改前的内容</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ArrayList使用代码案例"><a href="#ArrayList使用代码案例" class="headerlink" title="ArrayList使用代码案例"></a>ArrayList使用代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用ArrayList集合,注意通常使用ArrayList都是使用多态方式创建既:List list=new ArrayList()这种方式</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<span class="hljs-comment">// 默认</span><br>        <span class="hljs-comment">// 追加数据--&gt;会扩容到10大小的空间</span><br>        arrayList.add(<span class="hljs-string">&quot;小明&quot;</span>);<br>        System.out.println(arrayList);<br>        <span class="hljs-comment">// 插入数据</span><br>        arrayList.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(arrayList);<br>        <span class="hljs-comment">// 修改数据</span><br>        arrayList.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        System.out.println(arrayList);<br>        <span class="hljs-comment">// 移除数据</span><br>        arrayList.remove(<span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        System.out.println(arrayList);<br>        <span class="hljs-comment">// 获取数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> arrayList.get(<span class="hljs-number">0</span>);<br>        System.out.println(o);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="重写实现ArrayList部分功能"><a href="#重写实现ArrayList部分功能" class="headerlink" title="重写实现ArrayList部分功能"></a>重写实现ArrayList部分功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义实现ArrayList部分方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;<br>    <span class="hljs-comment">// 使用数组当做集合的底层存放</span><br>    <span class="hljs-keyword">private</span> Object[] elementData;<br><br>    <span class="hljs-comment">// 用于记录集合中元素数量的变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始化数组空间即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建数组并分配默认空间--&gt;默认10即可</span><br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建自定义容量大小的构造方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> initCapacity 初始化容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initCapacity)</span> &#123;<br>        <span class="hljs-comment">// 创建数组并分配默认空间--&gt;默认10即可</span><br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initCapacity];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加元素方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 传入需要添加的元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回是否添加成功</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object element)</span> &#123;<br>        <span class="hljs-comment">// 判断容量是否需要扩容</span><br>        ensureCapacityInternal();<br>        <span class="hljs-comment">// 将数据添加至数组中--&gt;其中size代表当前集合中的数据有多少</span><br>        <span class="hljs-built_in">this</span>.elementData[size++] = element;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用size与数组长度对比,如果size大了则代表需要扩容</span><br>        <span class="hljs-comment">/*if (size &gt;= this.elementData.length) &#123;</span><br><span class="hljs-comment">            // 将数组长度获取并赋值</span><br><span class="hljs-comment">            int oldLength = this.elementData.length;</span><br><span class="hljs-comment">            // 创建新数组并指定空间大小</span><br><span class="hljs-comment">            Object[] newElementData = new Object[oldLength + (oldLength &gt;&gt; 1) + 1];</span><br><span class="hljs-comment">            // 使用循环遍历方式将数据转义至新数组中--&gt;带着大家使用原始方式来一遍</span><br><span class="hljs-comment">            // 根据老数组的长度计算循环</span><br><span class="hljs-comment">            for (int i = 0; i &lt; this.elementData.length; i++) &#123;</span><br><span class="hljs-comment">                // 循环将原始数组数据复制给新数组</span><br><span class="hljs-comment">                newElementData[i] = this.elementData[i];</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            // 重新赋值后再将this.elementData重新赋值指向新数组内存地址</span><br><span class="hljs-comment">            this.elementData = newElementData;</span><br><span class="hljs-comment">        &#125;*/</span><br>        <span class="hljs-comment">// 模仿官方写法</span><br>        <span class="hljs-keyword">if</span> (size &gt;= <span class="hljs-built_in">this</span>.elementData.length) &#123;<br>            <span class="hljs-comment">// 将数组长度获取并赋值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.elementData.length;<br>            <span class="hljs-comment">// 计算新空间大小</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 使用数组工具类拷贝数组</span><br>            <span class="hljs-built_in">this</span>.elementData = Arrays.copyOf(<span class="hljs-built_in">this</span>.elementData, newCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取集合中的元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 传入下标索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回当前下标元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">// 验证传入的index是否超出索引范围</span><br>        rangeCheck(index);<br>        <span class="hljs-comment">// 返回数据</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.elementData[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查传入的index是否超出范围</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index 传入的下标索引</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">// 判断index是否小于0,以及是否大于size</span><br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;数组下标索引超出范围:&quot;</span> + index);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改元素</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index   传入需要修改的下标索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> element 传入修改的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回修改前的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Object element)</span> &#123;<br>        <span class="hljs-comment">// 验证下标是否合法</span><br>        rangeCheck(index);<br>        <span class="hljs-comment">// 将老数据提取</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">oldElementData</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.elementData[index];<br>        <span class="hljs-comment">// 修改index下标索引的数据</span><br>        <span class="hljs-built_in">this</span>.elementData[index] = element;<br>        <span class="hljs-keyword">return</span> oldElementData;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * toString方法用于打印数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回的是数组中的元素数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ArrayList&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;elementData=&quot;</span> + Arrays.toString(elementData) +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 测试方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建自己写的ArrayList</span><br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 添加数据</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            list.add(<span class="hljs-string">&quot;添加数据测试&quot;</span> + i);<br>        &#125;<br>        <span class="hljs-comment">// 打印结果</span><br>        System.out.println(list);<br>        <span class="hljs-comment">// 获取数据</span><br>        System.out.println(list.get(<span class="hljs-number">1</span>));<br>        System.out.println(list.get(<span class="hljs-number">3</span>));<br>        System.out.println(list.get(<span class="hljs-number">5</span>));<br>        System.out.println(list.get(<span class="hljs-number">7</span>));<br>        <span class="hljs-comment">// System.out.println(list.get(-1));</span><br>        System.out.println(<span class="hljs-string">&quot;============================================&quot;</span>);<br>        <span class="hljs-comment">// 修改数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">oldElementData</span> <span class="hljs-operator">=</span> list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(oldElementData);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="ArrayList集合中使用泛型约束添加数据的类型"><a href="#ArrayList集合中使用泛型约束添加数据的类型" class="headerlink" title="ArrayList集合中使用泛型约束添加数据的类型"></a>ArrayList集合中使用泛型约束添加数据的类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListGenericsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 集合中的泛型</span><br>        <span class="hljs-comment">// 在未使用泛型时向集合添加数据,由于数据的不统一,造成无法准确调用集合中元素的私有方法</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-comment">// 添加数据</span><br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;彭于晏1&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">18</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;彭于晏2&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">19</span>));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;彭于晏3&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>));<br>        <span class="hljs-comment">// 添加其他数据</span><br>        list.add(<span class="hljs-string">&quot;String类型数据&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;String类型数据&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;String类型数据&quot;</span>);<br>        <span class="hljs-comment">// 取出数据</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) list.get(<span class="hljs-number">2</span>);<br>        System.out.println(person.getName());<br>        <span class="hljs-comment">// 获取下标为3的数据,下标为3的是String类型,转换对象时不属于同一个类型,会出现类型转换异常</span><br>        <span class="hljs-comment">// Person person1 = (Person) list.get(3);</span><br>        <span class="hljs-comment">// System.out.println(person1.getName());</span><br>        <span class="hljs-comment">// 不转</span><br>        <span class="hljs-comment">// Object o = list.get(0);</span><br>        <span class="hljs-comment">// 只能调用Object类的方法</span><br><br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        <span class="hljs-comment">// 所以集合中有一个泛型的概念,泛型的作用就是用于约束类中的参数(参数可以代表:属性,形参,实参)传输--&gt;泛型用于约束/规则</span><br>        <span class="hljs-comment">// 使用泛型的集合</span><br>        <span class="hljs-comment">// 格式例如:List&lt;泛型类型(任意类型)&gt; list = new ArrayList&lt;&gt;();</span><br>        <span class="hljs-comment">// 定义一个List集合,泛型类型为Person,代表着只能向集合中添加Person对象数据</span><br>        List&lt;Person&gt; persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 添加数据,如果添加的数据不是泛型类型则会出现编译异常</span><br>        <span class="hljs-comment">// Required type:Person--&gt;需要类型是Person</span><br>        <span class="hljs-comment">// Provided:String--&gt;但是提供的是String类型</span><br>        <span class="hljs-comment">// persons.add(&quot;String类型数据&quot;);</span><br>        <span class="hljs-comment">// 添加准确数据</span><br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;彭于晏1&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">18</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;彭于晏2&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">19</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;彭于晏3&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">20</span>));<br>        <span class="hljs-comment">// 获取数据</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> persons.get(<span class="hljs-number">0</span>);<br>        System.out.println(person2);<br>        System.out.println(person2.getName() + <span class="hljs-string">&quot;-&quot;</span> + person2.getSex());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>**注意:**集合中使用泛型的目的是为了约束添加数据时的类型–&gt;统一数据类型,统一数据类型的目的使用使用时不用强转,同样也不会因为强转而发生类型转换异常–&gt;后期所有的集合都需要指定泛型类型</p>
<h3 id="List接口之实现类LinkedList"><a href="#List接口之实现类LinkedList" class="headerlink" title="List接口之实现类LinkedList"></a>List接口之实现类LinkedList</h3><h4 id="LinkedList概述"><a href="#LinkedList概述" class="headerlink" title="LinkedList概述"></a>LinkedList概述</h4><p>LinkedList底层是使用链表存储数据,使用链表存储数据是为了解决ArrayList使用数据存储数据的问题–&gt;数据存储查询速度快,但是插入删除速度慢,LinkedList链表结构是查询速度慢,插入删除速度快–&gt;LinkedList底层的存储方式就是使用双链表结构存储,在其中有一个内部类Node–&gt;节点,存储数据</p>
<h4 id="LinkedList中的链表是什么"><a href="#LinkedList中的链表是什么" class="headerlink" title="LinkedList中的链表是什么?"></a>LinkedList中的链表是什么?</h4><p>链表存储时数据不连续(属于数据之间是非连续空间),空间不连续也就意味着无法通过下标指向某一个元素,所以就出现了一个问题,只要查找数据就必须遍历所有的集合数据进行查找</p>
<h4 id="链表分为4种类型"><a href="#链表分为4种类型" class="headerlink" title="链表分为4种类型"></a>链表分为4种类型</h4><h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>单链表结构:单链表存储使用节点方式(节点就是一个对象),</p>
<p>存储数据时有两个属性：</p>
<ul>
<li><p>data：存放数据</p>
</li>
<li><p>next：指针，指向下一个节点地址，最后一个节点存储null</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/i-xiaoxin/image/master/12.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><p>双链表结构中使用双链表存储使用节点方式(节点就是一个对象)</p>
<p>存储数据时有三个属性</p>
<ul>
<li>prev–&gt;存储上一个节点地址,如果是第一个则存储null</li>
<li>data–&gt;存储数据</li>
<li>next–&gt;指针,存储下一个节点地址,如果是最后一个则存储null</li>
</ul>
<p><img src="https://raw.githubusercontent.com/i-xiaoxin/image/master/13.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="环形单链表"><a href="#环形单链表" class="headerlink" title="环形单链表"></a>环形单链表</h5><p>单链表结构:单链表存储使用节点方式(节点就是一个对象)</p>
<p>存储数据时有两个属性</p>
<ul>
<li>data(存放数据)</li>
<li>next(指针,指向下一个节点地址),最后一个节点的next存储的是第一个节点的地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/i-xiaoxin/image/master/14.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="环形双链表"><a href="#环形双链表" class="headerlink" title="环形双链表"></a>环形双链表</h5><p>双链表结构:双链表存储使用节点方式(节点就是一个对象)</p>
<p>存储数据时有三个属性</p>
<ul>
<li>prev–&gt;存储上一个节点地址,如果是第一个则存储最后一个节点的地址</li>
<li>data–&gt;存储数据</li>
<li>next–&gt;指针,存储下一个节点地址,如果是最后一个则存储第一个节点的地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/i-xiaoxin/image/master/15.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="LinkedList私有的方法-自己新增针对于增加和删除方法"><a href="#LinkedList私有的方法-自己新增针对于增加和删除方法" class="headerlink" title="LinkedList私有的方法(自己新增针对于增加和删除方法)"></a>LinkedList私有的方法(自己新增针对于增加和删除方法)</h4><ul>
<li><code>public void addFirst(E e)</code>:向集合的开头插入数据</li>
<li><code>public void addLast(E e)</code>:向集合的末尾插入数据</li>
<li><code>public E getFirst()</code>:获取集合中的第一个元素(如果第一个元素是null则抛异常)</li>
<li><code>public E getLast()</code>:获取集合中的最后一个元素(如果最后一个元素是null则抛异常)</li>
<li><code>public E peekFirst()</code>:获取集合中的第一个元素但是不删除(如果第一个元素是null则返回null)</li>
<li><code>public E peekLast()</code>:获取集合中的最后一个元素但是不删除(如果最后一个元素是null则返回null)</li>
<li><code>public E pollFirst()</code>:获取集合中的第一个元素,获取后直接删除</li>
<li><code>public E pollLast()</code>:获取集合中的最后一个元素,获取后直接删除</li>
<li><code>public E removeFirst()</code>:移除集合中的第一个元素</li>
<li><code>public E removeLast()</code>:移除集合中的最后一个元素</li>
</ul>
<p>LinkedList私有的方法代码案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 如果使用多态方式创建则无法使用LinkedList的私有方法</span><br>        <span class="hljs-comment">// List&lt;String&gt; list = new LinkedList&lt;&gt;();</span><br>        <span class="hljs-comment">// 所以创建时只能指定自己的对象</span><br>        LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `public void addFirst(E e)`:向集合的开头插入数据</span><br>        linkedList.addFirst(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(linkedList);<br>        linkedList.addFirst(<span class="hljs-string">&quot;梅超风&quot;</span>);<br>        System.out.println(linkedList);<br>        <span class="hljs-comment">// 2. `public void addLast(E e)`:向集合的末尾插入数据</span><br>        linkedList.addLast(<span class="hljs-string">&quot;岳不群&quot;</span>);<br>        System.out.println(linkedList);<br>        linkedList.addLast(<span class="hljs-string">&quot;林平之&quot;</span>);<br>        System.out.println(linkedList);<br>        <span class="hljs-comment">// 3. `public E getFirst()`:获取集合中的第一个元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> linkedList.getFirst();<br>        System.out.println(first);<br>        <span class="hljs-comment">// 4. `public E getLast()`:获取集合中的最后一个元素</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> linkedList.getLast();<br>        System.out.println(last);<br>        <span class="hljs-comment">// 5. `public E peekFirst()`:获取集合中的第一个元素但是不删除</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">peekFirst</span> <span class="hljs-operator">=</span> linkedList.peekFirst();<br>        System.out.println(peekFirst);<br>        <span class="hljs-comment">// 6. `public E peekLast()`:获取集合中的最后一个元素但是不删除</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">peekLast</span> <span class="hljs-operator">=</span> linkedList.peekLast();<br>        System.out.println(peekLast);<br>        System.out.println(linkedList);<br>        <span class="hljs-comment">// 7. `public E pollFirst()`:获取集合中的第一个元素,获取后直接删除</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">pollFirst</span> <span class="hljs-operator">=</span> linkedList.pollFirst();<br>        System.out.println(pollFirst);<br>        <span class="hljs-comment">// 8. `public E pollLast()`:获取集合中的最后一个元素,获取后直接删除</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">pollLast</span> <span class="hljs-operator">=</span> linkedList.pollLast();<br>        System.out.println(pollLast);<br>        System.out.println(linkedList);<br>        <span class="hljs-comment">// 9. `public E removeFirst()`:移除集合中的第一个元素</span><br>        linkedList.addFirst(<span class="hljs-string">&quot;梅超风&quot;</span>);<br>        System.out.println(linkedList);<br>        linkedList.removeFirst();<br>        System.out.println(linkedList);<br>        <span class="hljs-comment">// 10. `public E removeLast()`:移除集合中的最后一个元素</span><br>        linkedList.removeLast();<br>        System.out.println(linkedList);<br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);<br>        <span class="hljs-comment">// 都是使用多态方式创建时就不存在以上的私有定义的方法</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `boolean add(E e)`:向List集合中添加元素`常用`</span><br>        list.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 2. `void add(int index, E element)`:向List集合中指定位置添加元素</span><br>        list.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;梅超风&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 3. `boolean addAll(Collection&lt;? extends E&gt; c)`:将指定集合中的所有元素追加到此集合的末尾</span><br>        list.addAll(linkedList);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 4. `boolean addAll(int index, Collection&lt;? extends E&gt; c)`:将指定集合中的所有元素追加到此集合的指定位置</span><br>        <span class="hljs-comment">// 5. `boolean contains(Object o)`:检测此集合中是否包含指定元素`常用`</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContains</span> <span class="hljs-operator">=</span> list.contains(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(isContains);<br>        <span class="hljs-comment">// 6. `boolean containsAll(Collection&lt;?&gt; c)`:检测集合中是否包含另一个集合中的元素</span><br>        <span class="hljs-comment">// 7. `E get(int index)`:获取集合中指定下标索引的元素并返回`常用`</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">get</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>        System.out.println(get);<br>        <span class="hljs-comment">// 8. `E set(int index, E element)`:修改集合中指定下标索引的元素</span><br>        list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;东方不败&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 9. `int indexOf(Object o)`:在集合中查找元素如果存在则返回此元素的下标索引(返回第一次发现的下标索引)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">indexOf</span> <span class="hljs-operator">=</span> list.indexOf(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(indexOf);<br>        <span class="hljs-comment">// 10. `int lastIndexOf(Object o)`:在集合中查找元素如果存在则返回此元素的下标索引(返回最后一次发现的下标索引)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastIndexOf</span> <span class="hljs-operator">=</span> list.lastIndexOf(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(lastIndexOf);<br>        <span class="hljs-comment">// 11. `List&lt;E&gt; subList(int fromIndex, int toIndex)`:切割集合,指定起始位置和结束位置</span><br>        <span class="hljs-comment">// 12. `ListIterator&lt;E&gt; listIterator()`:返回List接口迭代器</span><br>        <span class="hljs-comment">// 13. `int size()`:返回集合中的元素数量`常用`</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br>        System.out.println(size);<br>        <span class="hljs-comment">// 14. `boolean isEmpty()`:判断集合是否为空`常用`</span><br>        System.out.println(list.isEmpty());<br>        <span class="hljs-comment">// 15. `Object[] toArray()`:将集合转为数组</span><br>        <span class="hljs-comment">// 16. `void clear()`:清空集合内元素</span><br>        <span class="hljs-comment">// 17. `Iterator&lt;E&gt; iterator()`:返回集合迭代器元素,用于遍历集合中的所有元素</span><br>        <span class="hljs-comment">// ListIterator迭代器</span><br>        ListIterator&lt;String&gt; listIterator = list.listIterator();<br>        <span class="hljs-keyword">while</span> (listIterator.hasNext()) &#123;<br>            System.out.println(listIterator.next());<br>        &#125;<br>        <span class="hljs-comment">// Iterator迭代器</span><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>        <span class="hljs-comment">// 清空clear</span><br>        list.clear();<br>        System.out.println(list.isEmpty());<br>        System.out.println(list.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="自定义实现LinkedList功能"><a href="#自定义实现LinkedList功能" class="headerlink" title="自定义实现LinkedList功能"></a>自定义实现LinkedList功能</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span> &#123;<br>    <span class="hljs-comment">// 用于存放首节点的属性--&gt;只记录集合中的第一个节点</span><br>    <span class="hljs-keyword">private</span> Node firstNode;<br>    <span class="hljs-comment">// 用于存放尾结点的属性--&gt;只记录集合中的最后一个节点</span><br>    <span class="hljs-keyword">private</span> Node lastNode;<br>    <span class="hljs-comment">// 用于存放集合中的元素数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object element)</span> &#123;<br>        <span class="hljs-comment">// 获取最后一个节点赋值给临时对象存放</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">tempNode</span> <span class="hljs-operator">=</span> lastNode;<br>        <span class="hljs-comment">// 创建新节点,每次创建都是最后一条所以next指向直接赋值null</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(tempNode, element, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 将新创建新节点当做是集合中的最后一个节点</span><br>        lastNode = newNode;<br>        <span class="hljs-comment">// 验证临时节点是否为空</span><br>        <span class="hljs-keyword">if</span> (tempNode == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将集合中的第一个节点的指向,指向到newNode节点上,代表是集合中的第一个节点</span><br>            firstNode = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 临时存储节点不为空则将临时节点的next指向下一个节点,下一个节点就是上面新增的</span><br>            tempNode.next = newNode;<br>        &#125;<br>        <span class="hljs-comment">// 将集合中的size++代表元素数量</span><br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取集合中的第一个节点</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getFirstNode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> firstNode.elementData;<br>    &#125;<br>    <span class="hljs-comment">// 获取集合中的最后一个节点</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getLastNode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> lastNode.elementData;<br>    &#125;<br>    <span class="hljs-comment">// size方法,获取长度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-comment">// 创建私有内部类--&gt;节点类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-comment">// 前一个节点</span><br>        Node prev;<br>        <span class="hljs-comment">// 数据</span><br>        Object elementData;<br>        <span class="hljs-comment">// 下一个节点</span><br>        Node next;<br>        <span class="hljs-comment">// 全参构造方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(Node prev, Object elementData, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.elementData = elementData;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedListDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建自定义LinkedList集合对象</span><br>        <span class="hljs-type">LinkedList</span> <span class="hljs-variable">linkedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();<br>        <span class="hljs-comment">// 添加数据</span><br>        linkedList.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        linkedList.add(<span class="hljs-string">&quot;梅超风&quot;</span>);<br>        linkedList.add(<span class="hljs-string">&quot;东方不败&quot;</span>);<br>        linkedList.add(<span class="hljs-string">&quot;岳不群&quot;</span>);<br>        linkedList.add(<span class="hljs-string">&quot;林平之&quot;</span>);<br>        linkedList.add(<span class="hljs-string">&quot;鞠婧祎&quot;</span>);<br>        <span class="hljs-comment">// 获取集合中第一个元素</span><br>        System.out.println(linkedList.getFirstNode());<br>        <span class="hljs-comment">// 获取集合中最后一个元素</span><br>        System.out.println(linkedList.getLastNode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="List接口之实现类Vector"><a href="#List接口之实现类Vector" class="headerlink" title="List接口之实现类Vector"></a>List接口之实现类Vector</h3><h4 id="Vector实现类概述"><a href="#Vector实现类概述" class="headerlink" title="Vector实现类概述"></a>Vector实现类概述</h4><p>Vector与ArrayList一模一样的,唯一的区别在于Vector是线程安全的而ArrayList是线程不安全</p>
<h4 id="List接口之Vector添加方法"><a href="#List接口之Vector添加方法" class="headerlink" title="List接口之Vector添加方法"></a>List接口之Vector添加方法</h4><ul>
<li><code>public synchronized boolean add(E e)</code>:向集合中追加元素<code>常用</code></li>
<li><code>public void add(int index, E element)</code>:向集合的指定下标索引插入元素</li>
<li><code>public synchronized boolean addAll(Collection&lt;? extends E&gt; c)</code>:将指定 Collection 中的所有元素附加到此 Vector 的末尾</li>
<li><code>public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)</code>:将指定 Collection 中的所有元素插入到此 Vector 的指定位置。将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）</li>
<li><code>public synchronized void addElement(E obj)</code>:向集合中追加元素</li>
</ul>
<h4 id="List接口之Vector删除方法"><a href="#List接口之Vector删除方法" class="headerlink" title="List接口之Vector删除方法"></a>List接口之Vector删除方法</h4><ul>
<li><code>public synchronized E remove(int index)</code>:指定下标索引删除集合中元素</li>
<li><code>public boolean remove(Object o)</code>:指定元素对象删除集合中的元素<code>常用</code></li>
<li><code>public synchronized boolean removeAll(Collection&lt;?&gt; c)</code>:从此 Vector 中删除包含在指定 Collection 中的所有元素</li>
<li><code>public synchronized void removeAllElements()</code>:从此Vector中删除所有元素并将其大小设置为零。</li>
<li><code>public synchronized boolean removeElement(Object obj)</code>:从此Vector中删除参数的第一个出现的元素。</li>
</ul>
<h4 id="List接口之Vector修改方法"><a href="#List接口之Vector修改方法" class="headerlink" title="List接口之Vector修改方法"></a>List接口之Vector修改方法</h4><ul>
<li><code>public synchronized E set(int index, E element)</code>:修改指定下标索引的元素<code>常用</code></li>
<li><code>public synchronized void setElementAt(E obj, int index)</code>:修改指定下标索引的元素</li>
<li><code>public synchronized void setSize(int newSize)</code>:设置集合中数组的大小</li>
</ul>
<h4 id="List接口之Vector查询方法"><a href="#List接口之Vector查询方法" class="headerlink" title="List接口之Vector查询方法"></a>List接口之Vector查询方法</h4><ul>
<li><code>public synchronized E get(int index)</code>:通过下标索引获取集合中的数据<code>常用</code></li>
<li><code>public int indexOf(Object o)</code>:指定元素获取集合中是否存在如果存在则返回第一次找到的下标索引否则返回-1</li>
<li><code>public synchronized int lastIndexOf(Object o)</code>:指定元素获取集合中是否存在如果存在则返回最后一次找到的下标索引否则返回-1</li>
</ul>
<h4 id="List接口之Vector其他方法"><a href="#List接口之Vector其他方法" class="headerlink" title="List接口之Vector其他方法"></a>List接口之Vector其他方法</h4><ul>
<li><code>public synchronized int size()</code>:获取集合中的元素数量–&gt;集合长度</li>
<li><code>public synchronized boolean isEmpty()</code>:判断集合是否为空</li>
<li><code>public void clear()</code>:清空集合中的所有数据</li>
</ul>
<h4 id="List接口之Vector代码案例"><a href="#List接口之Vector代码案例" class="headerlink" title="List接口之Vector代码案例"></a>List接口之Vector代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Vector对象</span><br>        Vector&lt;String&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>        <span class="hljs-comment">// #### 3. List接口之Vector添加方法</span><br>        <span class="hljs-comment">// 1. `public synchronized boolean add(E e)`:向集合中追加元素`常用`</span><br>        vector.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(vector);<br>        <span class="hljs-comment">// 2. `public void add(int index, E element)`:向集合的指定下标索引插入元素</span><br>        vector.add(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;梅超风&quot;</span>);<br>        System.out.println(vector);<br>        <span class="hljs-comment">// 3. `public synchronized boolean addAll(Collection&lt;? extends E&gt; c)`:将指定 Collection 中的所有元素附加到此 Vector 的末尾</span><br>        <span class="hljs-comment">// 4. `public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c)`:将指定 Collection 中的所有元素插入到此 Vector 的指定位置。将当前位于该位置的元素（如果有）和任何后续元素向右移动（增加它们的索引）</span><br>        <span class="hljs-comment">// 5. `public synchronized void addElement(E obj)`:向集合中追加元素</span><br>        vector.addElement(<span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        System.out.println(vector);<br>        <span class="hljs-comment">// #### 4. List接口之Vector删除方法</span><br>        <span class="hljs-comment">// 1. `public synchronized E remove(int index)`:指定下标索引删除集合中元素</span><br>        vector.remove(<span class="hljs-number">0</span>);<br>        System.out.println(vector);<br>        <span class="hljs-comment">// 2. `public boolean remove(Object o)`:指定元素对象删除集合中的元素`常用`</span><br>        <span class="hljs-comment">// 3. `public synchronized boolean removeAll(Collection&lt;?&gt; c)`:从此 Vector 中删除包含在指定 Collection 中的所有元素</span><br>        <span class="hljs-comment">// 4. `public synchronized void removeAllElements()`:从此Vector中删除所有元素并将其大小设置为零。</span><br>        <span class="hljs-comment">// 5. `public synchronized boolean removeElement(Object obj)`:从此Vector中删除参数的第一个出现的元素。</span><br>        <span class="hljs-comment">// #### 5. List接口之Vector修改方法</span><br>        <span class="hljs-comment">// 1. `public synchronized E set(int index, E element)`:修改指定下标索引的元素`常用`</span><br>        vector.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;陈冠希&quot;</span>);<br>        System.out.println(vector);<br>        <span class="hljs-comment">// 2. `public synchronized void setElementAt(E obj, int index)`:修改指定下标索引的元素</span><br>        <span class="hljs-comment">// 3. `public synchronized void setSize(int newSize)`:设置集合中数组的大小</span><br>        <span class="hljs-comment">// #### 6. List接口之Vector查询方法</span><br>        <span class="hljs-comment">// 1. `public synchronized E get(int index)`:通过下标索引获取集合中的数据`常用`</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> vector.get(<span class="hljs-number">0</span>);<br>        System.out.println(element);<br>        <span class="hljs-comment">// 2. `public int indexOf(Object o)`:指定元素获取集合中是否存在如果存在则返回第一次找到的下标索引否则返回-1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">indexOf</span> <span class="hljs-operator">=</span> vector.indexOf(<span class="hljs-string">&quot;陈冠希&quot;</span>);<br>        System.out.println(indexOf);<br>        <span class="hljs-comment">// 3. `public synchronized int lastIndexOf(Object o)`:指定元素获取集合中是否存在如果存在则返回最后一次找到的下标索引否则返回-1</span><br>        <span class="hljs-comment">// #### 7. List接口之Vector其他方法</span><br>        <span class="hljs-comment">// 1. `public synchronized int size()`:获取集合中的元素数量--&gt;集合长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> vector.size();<br>        System.out.println(size);<br>        <span class="hljs-comment">// 2. `public synchronized boolean isEmpty()`:判断集合是否为空</span><br>        System.out.println(vector.isEmpty());<br>        <span class="hljs-comment">// 3. `public void clear()`:清空集合中的所有数据</span><br>        vector.clear();<br>        System.out.println(vector.isEmpty());<br>        System.out.println(vector.size());<br>        System.out.println(<span class="hljs-string">&quot;================================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;================================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;================================================&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;================================================&quot;</span>);<br>        <span class="hljs-comment">// 使用常用方式创建Vector对象--&gt;多态创建</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>        <span class="hljs-comment">// 增加</span><br>        list.add(<span class="hljs-string">&quot;舒克&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;贝塔&quot;</span>);<br>        list.addAll(vector);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 删除</span><br>        list.remove(<span class="hljs-string">&quot;陈冠希&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 修改</span><br>        list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;开飞机的舒克&quot;</span>);<br>        list.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;开坦克的贝塔&quot;</span>);<br>        <span class="hljs-comment">// 获取数据</span><br>        System.out.println(list.get(<span class="hljs-number">0</span>));<br>        System.out.println(list.get(<span class="hljs-number">1</span>));<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="List接口的三个实现类对比"><a href="#List接口的三个实现类对比" class="headerlink" title="List接口的三个实现类对比"></a>List接口的三个实现类对比</h3><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul>
<li><p>底层数组实现,查询速度快,增删速度慢,速度慢的原因是:每次如果插入数据则需要将插入位置之后的数据都向后移一位</p>
</li>
<li><p>线程不安全的</p>
</li>
</ul>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ul>
<li><p>底层双链表实现,增删速度快,查询速度慢,速度慢的原因是:不管查询的是第几个都需要从头到尾查一遍</p>
</li>
<li><p>线程不安全的</p>
</li>
</ul>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ul>
<li>底层数组实现,查询速度快,增删速度慢,速度慢的原因是:每次如果插入数据则需要将插入位置之后的数据都向后移一位</li>
<li>线程安全的</li>
</ul>
<blockquote>
<p>ArrayList和Vector实现都是相同,包括方法都是相同,唯一的区别就是ArrayList是线程不安全的,Vector是线程安全</p>
</blockquote>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><h4 id="1-Map接口概述"><a href="#1-Map接口概述" class="headerlink" title="1. Map接口概述"></a>1. Map接口概述</h4><blockquote>
<p>Map翻译是(地图),程序中不是地图意思,Map集合存储数据是以<code>键(Key)值(Value)对</code>方式,有些类似于身份证<br>比如:身份证是身份证号对应身份证姓名<br>    1. 对应结果:123456789:小明<br>        1. 身份证号:Key(键)–&gt;身份证号是不允许重复的<br>        2. 身份证姓名:Value(值)–&gt;身份证姓名是允许重复的<br>    2. 以上身份证查找时使用身份证号查找当前这个人(使用身份证号查询身份证姓名)<br>Map集合也是相同,Map集合使用通过<code>Key(键)</code>获取<code>Value(值)</code>,并且<code>Key(键)不允许重复</code>,<code>Value(值)允许重复</code><br>Map集合是<code>java.util</code>包中,所以也是工具类,其直接子类是HashMap&#x2F;LinkedHashMap&#x2F;TreeMap&#x2F;HashTable&#x2F;Properties等等<br>Map集合是无序的(Key的排序是无序的)–&gt;虽然说无序但是有自己的排序规则,这个规则是ASCII码表如果超出127则按照Unicode码表</p>
<ol>
<li>无序代表<code>存储顺序</code>与<code>取出顺序</code>不一致</li>
<li>不能同通过下标索引获取数据</li>
</ol>
</blockquote>
<h4 id="2-Map接口中的常用方法"><a href="#2-Map接口中的常用方法" class="headerlink" title="2. Map接口中的常用方法"></a>2. Map接口中的常用方法</h4><ul>
<li><code>V put(K key, V value)</code>:向Map集合中添加键值对元素,不存在则添加,如果Key(键)重复则修改原有内容(不是重新添加覆盖),并返回添加的Value(值)内容<ol>
<li>key:键</li>
<li>value:值</li>
</ol>
</li>
<li><code>V get(Object key)</code>:指定Key(键)获取Value(值)</li>
<li><code>V remove(Object key)</code>:指定Key(键)移除<code>Key(键)Value(值)</code>–&gt;移除键值对</li>
<li><code>boolean containsKey(Object key)</code>:查看Map集合中是否包含指定的指定Key(键)</li>
<li><code>boolean containsValue(Object value)</code>:查看Map集合中是否包含指定的Value(值)</li>
<li><code>Collection&lt;V&gt; values()</code>:返回Map集合中的所有Value(值)</li>
<li><code>boolean isEmpty()</code>:判断Map集合是否为空</li>
<li><code>void clear()</code>:清空Map集合元素</li>
<li><code>int size()</code>:返回Map集合的元素数量(Key-Value代表一个)</li>
<li><code>Set&lt;K&gt; keySet()</code>:返回Map集合中的所有Key(键)值</li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>:返回Map集合中的所有Key-Value–&gt;返回所有键值对</li>
</ul>
<h4 id="3-map接口代码案例"><a href="#3-map接口代码案例" class="headerlink" title="3. map接口代码案例"></a>3. map接口代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Map集合,使用其子类HashMap创建--&gt;多态创建方式</span><br>        <span class="hljs-comment">// 常用Map泛型结构Map&lt;String, Object&gt;,Map&lt;String, String&gt;</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `V put(K key, V value)`:向Map集合中添加键值对元素,不存在则添加,如果Key(键)重复则修改原有内容(不是重新添加),并返回添加的Value(值)内容</span><br>        <span class="hljs-comment">// 1. key:键</span><br>        <span class="hljs-comment">// 2. value:值</span><br>        <span class="hljs-comment">// map.put(&quot;772004123055&quot;, &quot;彭于晏&quot;);</span><br>        <span class="hljs-comment">// map.put(&quot;771914123055&quot;, &quot;聂小倩&quot;);</span><br>        <span class="hljs-comment">// map.put(&quot;771999123055&quot;, &quot;聂小倩&quot;);</span><br>        <span class="hljs-comment">// // 771989123055是刘亦菲</span><br>        <span class="hljs-comment">// map.put(&quot;771989123055&quot;, &quot;刘亦菲&quot;);</span><br>        <span class="hljs-comment">// 重复添加相同的Key771989123055</span><br>        <span class="hljs-comment">// 如果Key重复则修改原有的Value值,而不是覆盖Key-Value</span><br>        map.put(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;苍老师&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;聂小倩&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;聂小倩&quot;</span>);<br>        <span class="hljs-comment">// 771989123055是刘亦菲</span><br>        map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;刘亦菲&quot;</span>);<br>        <span class="hljs-comment">// 重复添加相同的Key771989123055</span><br>        <span class="hljs-comment">// 如果Key重复则修改原有的Value值,而不是覆盖Key-Value</span><br>        map.put(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;苍老师&quot;</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 1. `V get(Object key)`:指定Key(键)获取Value(值)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;a&quot;</span>);<br>        System.out.println(value);<br>        <span class="hljs-comment">// 获取没有的值时是报错还是返回null?</span><br>        value = map.get(<span class="hljs-string">&quot;aa&quot;</span>);<br>        System.out.println(value);<br>        <span class="hljs-comment">// 第二个getOrDefault,当获取的key不存在时返回defaultValue--&gt;返回设置默认值</span><br>        value = map.getOrDefault(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;不存在&quot;</span>);<br>        System.out.println(value);<br>        value = map.getOrDefault(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;不存在&quot;</span>);<br>        System.out.println(value);<br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        <span class="hljs-comment">// 2. `V remove(Object key)`:指定Key(键)移除`Key(键)Value(值)`--&gt;移除键值对</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> map.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>        System.out.println(remove);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 3. `boolean containsKey(Object key)`:查看Map集合中是否包含指定的指定Key(键)</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContainsKey</span> <span class="hljs-operator">=</span> map.containsKey(<span class="hljs-string">&quot;f&quot;</span>);<br>        System.out.println(isContainsKey);<br>        isContainsKey = map.containsKey(<span class="hljs-string">&quot;ff&quot;</span>);<br>        System.out.println(isContainsKey);<br>        <span class="hljs-comment">// 4. `boolean containsValue(Object value)`:查看Map集合中是否包含指定的Value(值)</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContainsValue</span> <span class="hljs-operator">=</span> map.containsValue(<span class="hljs-string">&quot;苍老师&quot;</span>);<br>        System.out.println(isContainsValue);<br>        isContainsValue = map.containsValue(<span class="hljs-string">&quot;小泽老师&quot;</span>);<br>        System.out.println(isContainsValue);<br>        <span class="hljs-comment">// 5. `Collection&lt;V&gt; values()`:返回Map集合中的所有Value(值)</span><br>        Collection&lt;String&gt; values = map.values();<br>        System.out.println(values);<br>        <span class="hljs-comment">// 6. `boolean isEmpty()`:判断Map集合是否为空</span><br>        System.out.println(map.isEmpty());<br>        <span class="hljs-comment">// 8. `int size()`:返回Map集合的元素数量(Key-Value代表一个)</span><br>        System.out.println(map.size());<br>        <span class="hljs-comment">// Map集合的遍历只能通过keySet和entrySet遍历</span><br>        <span class="hljs-comment">// 9. `Set&lt;K&gt; keySet()`:返回Map集合中的所有Key(键)值</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        Set&lt;String&gt; keySet = map.keySet();<br>        <span class="hljs-comment">// 使用增强for循环遍历keySet</span><br>        <span class="hljs-keyword">for</span> (String key : keySet) &#123;<br>            <span class="hljs-comment">// 遍历key并使用key获取value</span><br>            System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + key + <span class="hljs-string">&quot;,value:&quot;</span> + map.get(key));<br>        &#125;<br>        <span class="hljs-comment">// 10. `Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()`:返回Map集合中的所有Key-Value--&gt;返回所有键值对</span><br>        <span class="hljs-comment">// Map.Entry--&gt;Entry是Map接口中的内部接口,作用就是返回Map集合中的Key-Value--&gt;返回键值对</span><br>        <span class="hljs-comment">// Entry接口中有两个方法,一个getKey(获取key)一个是getValue(获取value)</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();<br>        <span class="hljs-comment">// 遍历Set集合</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entrySet) &#123;<br>            <span class="hljs-comment">// 打印结果</span><br>            System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;,value:&quot;</span> + entry.getValue());<br>        &#125;<br>        <span class="hljs-comment">// 7. `void clear()`:清空Map集合元素</span><br>        map.clear();<br>        System.out.println(map);<br>        System.out.println(map.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Map接口之HashMap类"><a href="#Map接口之HashMap类" class="headerlink" title="Map接口之HashMap类"></a>Map接口之HashMap类</h3><h4 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1. HashMap概述"></a>1. HashMap概述</h4><blockquote>
<p>HashMap采用哈希算法实现,是Map接口中最常用的实现类,底层实现是使用哈希表存储数据,所以Key不允许重复,如果重复则修改Value值,HashMap在查找,删除,修改方法中效率非常高(全能增删改查效率都快)<br>HashMap的哈希表这种数据结构非常重要,并且应用场景非常的丰富,所以概念得懂</p>
</blockquote>
<ol>
<li>哈希表是嘛玩意儿?<ol>
<li>哈希表是基于链表实现,是链表的升级版本</li>
</ol>
</li>
<li>哈希表,数组,链表的优劣势<ol>
<li>数组:<ol>
<li>优势:查询速度快,可以直接指定下标索引查询</li>
<li>劣势:增删速度慢,增加或删除时需要将当前位置之后的所有元素向后移动</li>
</ol>
</li>
<li>链表:<ol>
<li>优势:增删速度快,原因是元素都是使用指向方式指向地址,不存在连续空间,想删除哪个直接删掉,并将前后的元素在相互关联,不用移动元素的位置</li>
<li>劣势:查询速度慢,因为没有连续空间,每一个元素知道的只有他的前一个节点和后一个节点是谁,不知道其他节点是谁,只能通过从头遍历到尾的方式查询</li>
</ol>
</li>
<li>哈希表:是吸取<code>数组</code>与<code>链表</code>的有点和缺点产生<ol>
<li>取长补短进行改进,改进后有<code>数组</code>+<code>链表</code>方式产生了<code>哈希表的数据结构</code>,全能增删改查效率都快(但是跟数组比起来还是差点意思的)</li>
</ol>
</li>
<li>数据结构的存储方式分为两种<ol>
<li>顺序存储结构–&gt;数组</li>
<li>链式存储结构–&gt;链表</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="2-哈希表概述"><a href="#2-哈希表概述" class="headerlink" title="2. 哈希表概述"></a>2. 哈希表概述</h4><blockquote>
<p>哈希表是由<code>数组</code>+<code>链表</code>实现</p>
</blockquote>
<h5 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h5><pre><code class="hljs">1. 二叉树是树形结构,使用的非常多,一般般情况使用时是针对于结构进行升级以及使用算法计算如何分叉,由一个节点及两根互不相交的分叉来作为左子树和右子树,实现时分为5种形态
2. 五种二叉树形态
![](./img/18.png)
    1. 第一种情况:空树
    2. 第二种情况:仅有一个节点的二叉树
    3. 第三种情况:仅有左子树的二叉树
    4. 第四种情况:仅有右子树的二叉树
    5. 第五种情况:有左右子树的非空二叉树(完整二叉树)
2. 二叉树是如何排序的
    1. 分为左右子树,左子树数字小于上一个节点,右子树数字大于上一个节点
    2. 例如有这么一组数据--&gt;25,14,27,21,19,26
    ![](./img/19.png)
3. 二叉树实现了排序功能可以快速的检索,但是如果本身数据是有序的(例如:6,5,4,3,2,1)那么这种数据就会倾倒式的一边倒,要么向左要么向右--&gt;一旦发生这种情况那就是普通的链表结构了
4. 二叉树的缺点是不能排序顺序数字的结构,一旦排序则变回普通的链表结构例如:数据为(1,2,3,4,5,6)
    ![](./img/20.png)
</code></pre>
<h5 id="2-平衡二叉树"><a href="#2-平衡二叉树" class="headerlink" title="2. 平衡二叉树"></a>2. 平衡二叉树</h5><blockquote>
<p>为了避免二叉树出现的一边倒的情况,科学家研究除了平衡二叉树,比如在原有的数据将数据进行平衡,会将一组数据的排序方式改变,当前已知的是不管怎么排序是不会出现一边倒超出两个及以上节点的情况,但是排序时次数是不确定,当前有可能排序次数早很多次的情况,如果出现不平排序次数不确定,有可能会重新将所有的数据进行排序,造成速度慢情况<br>缺点是如果出现了添加的元素过多时他的排序次数是不确定的,有可能会出现重新排列所有的情况,可能会造成效率低多做无用功的操作,有问题则需要解决–&gt;科学家又研究除了一个叫做红黑二叉树的结构</p>
</blockquote>
<h5 id="3-红黑二叉树"><a href="#3-红黑二叉树" class="headerlink" title="3. 红黑二叉树"></a>3. 红黑二叉树</h5><blockquote>
<p>红黑二叉树是为了解决平衡二叉树造成的不确定移动次数的情况,升级版本;红黑二叉树又被称之为<code>红黑树</code>,是有二叉树组成,同时有事一颗自平衡排序二叉树</p>
</blockquote>
<ol>
<li>红黑树在原有的平衡二叉树基础上升级了几个特点<ul>
<li>每个节点要么是<code>红色</code>,要么是<code>黑色</code></li>
<li>根节点始终保持<code>黑色</code></li>
<li>所有的叶子节点都是为空节点–&gt;null,并且全是<code>黑色</code></li>
<li>每个<code>红色</code>节点的两个子节点都是<code>黑色</code>,但是每个叶子到根的路径上<code>不会出现两个连续</code>的<code>红色</code>节点</li>
<li>从任意节点到子节点中的每个叶子节点的路径可以包含相同数量的黑色节点</li>
</ul>
</li>
</ol>
<blockquote>
<p>通过以上的升级得出最终的结论就是红黑树有两个颜色,黑色允许重复,红色不允许重复(上下节点)<br>红黑树的操作:插入删除,左旋,右旋,着色,每次插入或删除一个节点时都可能会导致不符合规范的情况(超出两个节点的范围了),红黑树就进行修复,使用左旋与右旋和着色操作进行修复,用于保持红黑树的结构始终平衡<br>红黑树动画演示页面:<code>https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</code></p>
</blockquote>
<h5 id="4-二叉树-x2F-平衡二叉树-x2F-红黑二叉树"><a href="#4-二叉树-x2F-平衡二叉树-x2F-红黑二叉树" class="headerlink" title="4. 二叉树&#x2F;平衡二叉树&#x2F;红黑二叉树"></a>4. 二叉树&#x2F;平衡二叉树&#x2F;红黑二叉树</h5><ol>
<li>二叉树基于链表,为了解决链表的查询问题而生,存在的问题,如果数据是递增的则会出现一边倒的情况,相当于最终还是链表结构,不是二叉树结构梁</li>
<li>平衡二叉树基于二叉树为了解决出现一边倒的情况而生,排序时会根据数据的结构进行自动平衡(不会超过2个多节点,一旦超过则重新排序),但是也有问题,如果数据过多在排序过程中容易出现整体排序(无法确定排序次数)可能造成影响性能的问题</li>
<li>红黑二叉树基于平衡二叉树,是升级版本,为了解决平衡二叉树排序过程中出现未知排序次数造成的性能问题而生,使用<code>红</code>&#x2F;<code>黑</code>两色用于进行标识,并且永远不会出现连续的<code>红色</code>,<code>黑色</code>是会出现连续情况,并且<code>黑色</code>始终都会比<code>红色</code>多</li>
</ol>
<h4 id="3-Hash-Map构造方法"><a href="#3-Hash-Map构造方法" class="headerlink" title="3. Hash Map构造方法"></a>3. Hash Map构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用空参构造方法创建Map集合,会有默认容量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><span class="hljs-comment">// 指定初始化容量创建Map集合</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-HashMap常用方法–-gt-由于HashMap使用的都是他爹Map接口的方法-所以方法一致"><a href="#4-HashMap常用方法–-gt-由于HashMap使用的都是他爹Map接口的方法-所以方法一致" class="headerlink" title="4. HashMap常用方法–&gt;由于HashMap使用的都是他爹Map接口的方法,所以方法一致"></a>4. HashMap常用方法–&gt;由于HashMap使用的都是他爹Map接口的方法,所以方法一致</h4><ul>
<li><code>V put(K key, V value)</code>:向Map集合中添加键值对元素,不存在则添加,如果Key(键)重复则修改原有内容(不是重新添加覆盖),并返回添加的Value(值)内容<ol>
<li>key:键</li>
<li>value:值</li>
</ol>
</li>
<li><code>V get(Object key)</code>:指定Key(键)获取Value(值)</li>
<li><code>V remove(Object key)</code>:指定Key(键)移除<code>Key(键)Value(值)</code>–&gt;移除键值对</li>
<li><code>boolean containsKey(Object key)</code>:查看Map集合中是否包含指定的指定Key(键)</li>
<li><code>boolean containsValue(Object value)</code>:查看Map集合中是否包含指定的Value(值)</li>
<li><code>Collection&lt;V&gt; values()</code>:返回Map集合中的所有Value(值)</li>
<li><code>boolean isEmpty()</code>:判断Map集合是否为空</li>
<li><code>void clear()</code>:清空Map集合元素</li>
<li><code>int size()</code>:返回Map集合的元素数量(Key-Value代表一个)</li>
<li><code>Set&lt;K&gt; keySet()</code>:返回Map集合中的所有Key(键)值</li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>:返回Map集合中的所有Key-Value–&gt;返回所有键值对</li>
</ul>
<h4 id="5-HashMap集合代码案例"><a href="#5-HashMap集合代码案例" class="headerlink" title="5. HashMap集合代码案例"></a>5. HashMap集合代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Map集合,使用其子类HashMap创建--&gt;多态创建方式</span><br>        <span class="hljs-comment">// 常用Map泛型结构Map&lt;String, Object&gt;,Map&lt;String, String&gt;</span><br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `V put(K key, V value)`:向Map集合中添加键值对元素,不存在则添加,如果Key(键)重复则修改原有内容(不是重新添加),并返回添加的Value(值)内容</span><br>        <span class="hljs-comment">// 1. key:键</span><br>        <span class="hljs-comment">// 2. value:值</span><br>        <span class="hljs-comment">// map.put(&quot;772004123055&quot;, &quot;彭于晏&quot;);</span><br>        <span class="hljs-comment">// map.put(&quot;771914123055&quot;, &quot;聂小倩&quot;);</span><br>        <span class="hljs-comment">// map.put(&quot;771999123055&quot;, &quot;聂小倩&quot;);</span><br>        <span class="hljs-comment">// // 771989123055是刘亦菲</span><br>        <span class="hljs-comment">// map.put(&quot;771989123055&quot;, &quot;刘亦菲&quot;);</span><br>        <span class="hljs-comment">// 重复添加相同的Key771989123055</span><br>        <span class="hljs-comment">// 如果Key重复则修改原有的Value值,而不是覆盖Key-Value</span><br>        map.put(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;苍老师&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;聂小倩&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;聂小倩&quot;</span>);<br>        <span class="hljs-comment">// 771989123055是刘亦菲</span><br>        map.put(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;刘亦菲&quot;</span>);<br>        <span class="hljs-comment">// 重复添加相同的Key771989123055</span><br>        <span class="hljs-comment">// 如果Key重复则修改原有的Value值,而不是覆盖Key-Value</span><br>        map.put(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-string">&quot;苍老师&quot;</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 1. `V get(Object key)`:指定Key(键)获取Value(值)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;a&quot;</span>);<br>        System.out.println(value);<br>        <span class="hljs-comment">// 获取没有的值时是报错还是返回null?</span><br>        value = map.get(<span class="hljs-string">&quot;aa&quot;</span>);<br>        System.out.println(value);<br>        <span class="hljs-comment">// 第二个getOrDefault,当获取的key不存在时返回defaultValue--&gt;返回设置默认值</span><br>        value = map.getOrDefault(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;不存在&quot;</span>);<br>        System.out.println(value);<br>        value = map.getOrDefault(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;不存在&quot;</span>);<br>        System.out.println(value);<br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        <span class="hljs-comment">// 2. `V remove(Object key)`:指定Key(键)移除`Key(键)Value(值)`--&gt;移除键值对</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> map.remove(<span class="hljs-string">&quot;a&quot;</span>);<br>        System.out.println(remove);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 3. `boolean containsKey(Object key)`:查看Map集合中是否包含指定的指定Key(键)</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContainsKey</span> <span class="hljs-operator">=</span> map.containsKey(<span class="hljs-string">&quot;f&quot;</span>);<br>        System.out.println(isContainsKey);<br>        isContainsKey = map.containsKey(<span class="hljs-string">&quot;ff&quot;</span>);<br>        System.out.println(isContainsKey);<br>        <span class="hljs-comment">// 4. `boolean containsValue(Object value)`:查看Map集合中是否包含指定的Value(值)</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isContainsValue</span> <span class="hljs-operator">=</span> map.containsValue(<span class="hljs-string">&quot;苍老师&quot;</span>);<br>        System.out.println(isContainsValue);<br>        isContainsValue = map.containsValue(<span class="hljs-string">&quot;小泽老师&quot;</span>);<br>        System.out.println(isContainsValue);<br>        <span class="hljs-comment">// 5. `Collection&lt;V&gt; values()`:返回Map集合中的所有Value(值)</span><br>        Collection&lt;String&gt; values = map.values();<br>        System.out.println(values);<br>        <span class="hljs-comment">// 6. `boolean isEmpty()`:判断Map集合是否为空</span><br>        System.out.println(map.isEmpty());<br>        <span class="hljs-comment">// 8. `int size()`:返回Map集合的元素数量(Key-Value代表一个)</span><br>        System.out.println(map.size());<br>        <span class="hljs-comment">// Map集合的遍历只能通过keySet和entrySet遍历</span><br>        <span class="hljs-comment">// 9. `Set&lt;K&gt; keySet()`:返回Map集合中的所有Key(键)值</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        Set&lt;String&gt; keySet = map.keySet();<br>        <span class="hljs-comment">// 使用增强for循环遍历keySet</span><br>        <span class="hljs-keyword">for</span> (String key : keySet) &#123;<br>            <span class="hljs-comment">// 遍历key并使用key获取value</span><br>            System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + key + <span class="hljs-string">&quot;,value:&quot;</span> + map.get(key));<br>        &#125;<br>        <span class="hljs-comment">// 10. `Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()`:返回Map集合中的所有Key-Value--&gt;返回所有键值对</span><br>        <span class="hljs-comment">// Map.Entry--&gt;Entry是Map接口中的内部接口,作用就是返回Map集合中的Key-Value--&gt;返回键值对</span><br>        <span class="hljs-comment">// Entry接口中有两个方法,一个getKey(获取key)一个是getValue(获取value)</span><br>        System.out.println(<span class="hljs-string">&quot;======================================================&quot;</span>);<br>        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();<br>        <span class="hljs-comment">// 遍历Set集合</span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entrySet) &#123;<br>            <span class="hljs-comment">// 打印结果</span><br>            System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;,value:&quot;</span> + entry.getValue());<br>        &#125;<br>        <span class="hljs-comment">// 7. `void clear()`:清空Map集合元素</span><br>        map.clear();<br>        System.out.println(map);<br>        System.out.println(map.size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-HashMap的实现是什么"><a href="#6-HashMap的实现是什么" class="headerlink" title="6. HashMap的实现是什么?"></a>6. HashMap的实现是什么?</h4><h5 id="1-HashMapJDK1-7跟JDK1-8的切换红黑树原码分析"><a href="#1-HashMapJDK1-7跟JDK1-8的切换红黑树原码分析" class="headerlink" title="1. HashMapJDK1.7跟JDK1.8的切换红黑树原码分析"></a>1. HashMapJDK1.7跟JDK1.8的切换<code>红黑树</code>原码分析</h5><ol>
<li>HashMap的实现JDK1.7跟JDK1.8不同,JDK1.7中HashMap是使用<code>数组</code>加<code>链表</code>的结合体实现,JDK1.8是<code>数组</code>加<code>链表</code>加<code>红黑树</code>实现,JDK1.7之前只能使用数组加链表的实现,JDK1.8后在数据量少的时候使用的是<code>数组</code>加<code>链表</code>实现,而当数组存储到8个长度时则更改为<code>数组</code>加<code>红黑树</code>实现</li>
<li>查看HashMap具体实现–&gt;put方法,什么时候用数组加链表,什么时候用数组加红黑树,以及为什么Key不能重复是如何实现的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 是否使用红黑树的阈值--&gt;如果长度是在8以内,使用的是JDK1.8的数组加链表,如果是8以上则使用数组加红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// HashMap的普通方法</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 调用putVal方法</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 循环验证当前数组中的数据是有多少</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 将p.next指向的地址赋值给e变量,并判断是否为null</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 如果为null则进入</span><br>                    <span class="hljs-comment">// 调用newNode方法创建新节点,并赋值给p.next代表上一个节点的指向位置,最后一个节点</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 用循环判断当前二叉树统计的次数是否大于等于7</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>)<br>                        <span class="hljs-comment">// 如果binCount大于等于7则代表当前存的数据已经是8条,调用treeifyBin方法使用红黑树</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 上方判断如果大于等于7则使用红黑树的代码</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 创建的就是红黑树</span><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 真实创建红黑树并赋值</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 红黑树内部类</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-comment">// parent是红黑树的父级连接</span><br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    <span class="hljs-comment">// left是红黑树的左子树</span><br>    TreeNode&lt;K,V&gt; left;<br>    <span class="hljs-comment">// right是红黑树的右子树</span><br>    TreeNode&lt;K,V&gt; right;<br>    <span class="hljs-comment">// prev用于连接节点,有利于删除</span><br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-comment">// red用于记录当前节点是红树还是黑树</span><br>    <span class="hljs-type">boolean</span> red;<br>    TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(hash, key, val, next);<br>    &#125;<br>    <span class="hljs-comment">// ...省略n行实现代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-HashMap的put方法为何不能添加重复的key源码分析"><a href="#2-HashMap的put方法为何不能添加重复的key源码分析" class="headerlink" title="2. HashMap的put方法为何不能添加重复的key源码分析"></a>2. HashMap的put方法为何不能添加重复的key源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">// 声明Node节点数组</span><br>    HashMap.Node&lt;K, V&gt;[] tab;<br>    <span class="hljs-comment">// 声明Node节点对象</span><br>    HashMap.Node&lt;K, V&gt; p;<br>    <span class="hljs-comment">// 声明两个int变量</span><br>    <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">// 将table数据赋值给tab然后判断是否等于null</span><br>    <span class="hljs-comment">// 如果tab不等于null则讲tab.length赋值n变量，然后判断是否为0</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 重新设置长度--》然后创建对象并返回</span><br>        <span class="hljs-comment">// 返回对象后又获取数组的长度--&gt;赋值给n</span><br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// hash是调用方法计算而来</span><br>    <span class="hljs-comment">// 讲n数组长度-1，并使用按位与hash计算，将最终的值赋值给i（赋值后如果数字相同则直接向后继续添加）</span><br>    <span class="hljs-comment">// tab[i = (n - 1) &amp; hash]--&gt;例如key是name,最终计算出的值为8，讲数组下标为8的数据取出</span><br>    <span class="hljs-comment">// p--&gt;Node节点对象，判断是否等于null</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 如果等于null创建Node节点对象赋值进去</span><br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 声明了一个Node节点对象e</span><br>        HashMap.Node&lt;K, V&gt; e;<br>        <span class="hljs-comment">// Key的泛型名称</span><br>        K k;<br>        <span class="hljs-comment">// p.hash == hash下一行是解释</span><br>        <span class="hljs-comment">// p.hash是当前tab[i]Node数组下标中的值，hash是传入的Key值如果相同则代表当前他们可能是相同数据</span><br>        <span class="hljs-comment">// (k = p.key) == key--》基本数据类型</span><br>        <span class="hljs-comment">// 将tab[i]Node数组下标中的值--》p.key=原本可能存在的key，与传入的key对比(基本数据类型)</span><br>        <span class="hljs-comment">// key != null &amp;&amp; key.equals(k)</span><br>        <span class="hljs-comment">// 先验证传入的key是否为null如果不是则使用key.equals()对比内容是否相同</span><br>        <span class="hljs-comment">// 这里是验证传入Key是否已存在的根本位置</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-comment">// 用p节点赋值给e节点</span><br>            e = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> HashMap.TreeNode)<br>            e = ((HashMap.TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果hash相同而equals不同则进入这里执行</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// p.next--&gt;指向的下一个节点赋值给e</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 将创建的新节点地址赋值给p.next的指向</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 与上面的验证相同</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 验证e节点是否不为null</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 将value赋值给oldValue（老值）</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-comment">// 判断oldValue是否为null</span><br>            <span class="hljs-comment">// 是put方法调用的传入的值，传入默认就是false</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">// 将调用put时传入的值直接赋值给e.value</span><br>                e.value = value;<br>            <span class="hljs-comment">// 这个方法就是将e节点对象重新赋值到节点数组中</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回修改前的值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Map接口之LinkedHashMap类"><a href="#Map接口之LinkedHashMap类" class="headerlink" title="Map接口之LinkedHashMap类"></a>Map接口之LinkedHashMap类</h3><h4 id="1-LinkedHashMap类概述"><a href="#1-LinkedHashMap类概述" class="headerlink" title="1. LinkedHashMap类概述"></a>1. LinkedHashMap类概述</h4><blockquote>
<p>LinkedHashMap类与HashMap相同,唯一不同点在于他底层是采用的<code>链表</code>+<code>哈希表</code>结构,由于是链表实现所以他的元素顺序能够保证(有序的:存入数据与取出顺序相同),其他的实现与HashMap基本完全一致,同样key也是不允许重复,<code>LinkedHashMap类是继承自HashMap类的</code></p>
</blockquote>
<h4 id="2-LinkedHashMap类的构造方法"><a href="#2-LinkedHashMap类的构造方法" class="headerlink" title="2. LinkedHashMap类的构造方法"></a>2. LinkedHashMap类的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建LinkedHashMap集合对象,使用默认长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用他爹HashMap的构造方法</span><br>    <span class="hljs-built_in">super</span>();<br>    accessOrder = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 创建LinkedHashMap集合对象并指定初始容量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-comment">// 调用他爹HashMap构造方法</span><br>    <span class="hljs-built_in">super</span>(initialCapacity);<br>    accessOrder = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-LinkedHashMap类的常用方法-由于是直接继承自HashMap类的所以很多方法都是用的他爹的"><a href="#3-LinkedHashMap类的常用方法-由于是直接继承自HashMap类的所以很多方法都是用的他爹的" class="headerlink" title="3. LinkedHashMap类的常用方法(由于是直接继承自HashMap类的所以很多方法都是用的他爹的)"></a>3. LinkedHashMap类的常用方法(由于是直接继承自HashMap类的所以很多方法都是用的他爹的)</h4><ul>
<li><code>V put(K key, V value)</code>:向Map集合中添加键值对元素,不存在则添加,如果Key(键)重复则修改原有内容(不是重新添加覆盖),并返回添加的Value(值)内容<ol>
<li>key:键</li>
<li>value:值</li>
</ol>
</li>
<li><code>V get(Object key)</code>:指定Key(键)获取Value(值)</li>
<li><code>V remove(Object key)</code>:指定Key(键)移除<code>Key(键)Value(值)</code>–&gt;移除键值对</li>
<li><code>boolean containsKey(Object key)</code>:查看Map集合中是否包含指定的指定Key(键)</li>
<li><code>boolean containsValue(Object value)</code>:查看Map集合中是否包含指定的Value(值)</li>
<li><code>Collection&lt;V&gt; values()</code>:返回Map集合中的所有Value(值)</li>
<li><code>boolean isEmpty()</code>:判断Map集合是否为空</li>
<li><code>void clear()</code>:清空Map集合元素</li>
<li><code>int size()</code>:返回Map集合的元素数量(Key-Value代表一个)</li>
<li><code>Set&lt;K&gt; keySet()</code>:返回Map集合中的所有Key(键)值</li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>:返回Map集合中的所有Key-Value–&gt;返回所有键值对</li>
</ul>
<h4 id="4-LinkedHashMap类代码案例"><a href="#4-LinkedHashMap类代码案例" class="headerlink" title="4. LinkedHashMap类代码案例"></a>4. LinkedHashMap类代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashMapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建 LinkedHashMap类 对象--&gt;多态方式创建</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `V put(K key, V value)`:向Map集合中添加键值对元素,不存在则添加,如果Key(键)重复则修改原有内容(不是重新添加覆盖),并返回添加的Value(值)内容`常用掌握`</span><br>        <span class="hljs-comment">// 1. key:键</span><br>        <span class="hljs-comment">// 2. value:值</span><br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>        map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;男神&quot;</span>);<br>        <span class="hljs-comment">// 赋值一个相同的</span><br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 1. `V get(Object key)`:指定Key(键)获取Value(值)`常用掌握`</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>        <span class="hljs-comment">// 2. `V remove(Object key)`:指定Key(键)移除`Key(键)Value(值)`--&gt;移除键值对</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">abc</span> <span class="hljs-operator">=</span> map.remove(<span class="hljs-string">&quot;abc&quot;</span>);<br>        System.out.println(abc);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 3. `boolean containsKey(Object key)`:查看Map集合中是否包含指定的指定Key(键)</span><br>        System.out.println(map.containsKey(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 4. `boolean containsValue(Object value)`:查看Map集合中是否包含指定的Value(值)</span><br>        System.out.println(map.containsValue(<span class="hljs-string">&quot;吴彦祖&quot;</span>));<br>        <span class="hljs-comment">// 5. `Collection&lt;V&gt; values()`:返回Map集合中的所有Value(值)</span><br>        Collection&lt;Object&gt; values = map.values();<br>        System.out.println(values);<br>        <span class="hljs-comment">// 6. `boolean isEmpty()`:判断Map集合是否为空</span><br>        System.out.println(map.isEmpty());<br>        <span class="hljs-comment">// 8. `int size()`:返回Map集合的元素数量(Key-Value代表一个)`常用掌握`</span><br>        System.out.println(map.size());<br>        <span class="hljs-comment">// 9. `Set&lt;K&gt; keySet()`:返回Map集合中的所有Key(键)值</span><br>        Set&lt;String&gt; strings = map.keySet();<br>        System.out.println(strings);<br>        <span class="hljs-comment">// 10. `Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()`:返回Map集合中的所有Key-Value--&gt;返回所有键值对</span><br>        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();<br>        System.out.println(entries);<br>        <span class="hljs-comment">// 7. `void clear()`:清空Map集合元素</span><br>        map.clear();<br>        <span class="hljs-comment">// 打印数组长度以及是否为空</span><br>        System.out.println(map.size());<br>        System.out.println(map.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Map接口之Hashtable类"><a href="#Map接口之Hashtable类" class="headerlink" title="Map接口之Hashtable类"></a>Map接口之Hashtable类</h3><h4 id="1-Hashtable类概述"><a href="#1-Hashtable类概述" class="headerlink" title="1. Hashtable类概述"></a>1. Hashtable类概述</h4><blockquote>
<p>Hashtable类与HashMap类方法及构造方法基本都是相同的,底层依旧是采用<code>数组</code>+<code>链表</code>或<code>数组</code>+<code>红黑树</code>,增删改查速度也很快,唯一的区别在于Hashtable是线程安全的(使用了synchronized关键字修饰),HashMap是线程不安全的</p>
</blockquote>
<h4 id="2-Hashtable类的构造方法"><a href="#2-Hashtable类的构造方法" class="headerlink" title="2. Hashtable类的构造方法"></a>2. Hashtable类的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Hashtable集合对象,默认容量是11</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Hashtable</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-number">11</span>, <span class="hljs-number">0.75f</span>);<br>&#125;<br><span class="hljs-comment">// 创建HashTable集合对象,并指定初始化容量</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Hashtable</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-number">0.75f</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-Hashtable类的常用方法"><a href="#3-Hashtable类的常用方法" class="headerlink" title="3. Hashtable类的常用方法"></a>3. Hashtable类的常用方法</h4><ul>
<li><code>public synchronized V put(K key, V value)</code>:向集合中添加元素<ul>
<li>key:键值</li>
<li>value:值</li>
</ul>
</li>
<li><code>public synchronized V get(Object key)</code>:通过key获取集合中指定value值</li>
<li><code>public synchronized V remove(Object key)</code>:通过key移除集合中的元素</li>
<li><code>public Set&lt;K&gt; keySet()</code>:获取集合中的所有key值</li>
<li><code>public Collection&lt;V&gt; values()</code>:获取集合中所有值</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>:获取集合中所有键值对(key-value)</li>
<li><code>public synchronized int size()</code>:获取集合中所有元素数量</li>
<li><code>public synchronized boolean isEmpty()</code>:判断集合是否为空</li>
<li><code>public synchronized void clear()</code>:清空集合元素</li>
</ul>
<h4 id="4-Hashtable类代码案例"><a href="#4-Hashtable类代码案例" class="headerlink" title="4. Hashtable类代码案例"></a>4. Hashtable类代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTableDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建HashTable对象</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `public synchronized V put(K key, V value)`:向集合中添加元素</span><br>        <span class="hljs-comment">// 1. key:键值</span><br>        <span class="hljs-comment">// 2. value:值</span><br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小泽老师&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">40</span>);<br>        map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;nation&quot;</span>, <span class="hljs-string">&quot;小日子过的不错的国家&quot;</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 2. `public synchronized V get(Object key)`:通过key获取集合中指定value值</span><br>        System.out.println(map.get(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 3. `public synchronized V remove(Object key)`:通过key移除集合中的元素</span><br>        System.out.println(map);<br>        System.out.println(map.remove(<span class="hljs-string">&quot;nation&quot;</span>));<br>        System.out.println(map);<br>        <span class="hljs-comment">// 4. `public Set&lt;K&gt; keySet()`:获取集合中的所有key值</span><br>        Set&lt;String&gt; strings = map.keySet();<br>        System.out.println(strings);<br>        <span class="hljs-comment">// 5. `public Collection&lt;V&gt; values()`:获取集合中所有值</span><br>        Collection&lt;Object&gt; values = map.values();<br>        System.out.println(values);<br>        <span class="hljs-comment">// 6. `public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()`:获取集合中所有键值对(key-value)</span><br>        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();<br>        System.out.println(entries);<br>        <span class="hljs-comment">// 7. `public synchronized int size()`:获取集合中所有元素数量</span><br>        System.out.println(map.size());<br>        <span class="hljs-comment">// 8. `public synchronized boolean isEmpty()`:判断集合是否为空</span><br>        System.out.println(map.isEmpty());<br>        <span class="hljs-comment">// 9. `public synchronized void clear()`:清空集合元素</span><br>        map.clear();<br>        System.out.println(map.size());<br>        System.out.println(map.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Map接口之TreeMap类"><a href="#Map接口之TreeMap类" class="headerlink" title="Map接口之TreeMap类"></a>Map接口之TreeMap类</h3><h4 id="1-TreeMap类概述"><a href="#1-TreeMap类概述" class="headerlink" title="1. TreeMap类概述"></a>1. TreeMap类概述</h4><blockquote>
<p>TreeMap底层使用红黑树实现,与HashMap的却别是不在验证长度更改红黑树,其他与HashMap相同</p>
</blockquote>
<h4 id="2-TreeMap类的构造方法"><a href="#2-TreeMap类的构造方法" class="headerlink" title="2. TreeMap类的构造方法"></a>2. TreeMap类的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建TreeMap集合对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// comparator是比较器,比较器的作用是 用于排序</span><br>    comparator = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 创建TreeMap集合对象,并指定Map集合将数据添加至TreeMap集合中</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    comparator = <span class="hljs-literal">null</span>;<br>    putAll(m);<br>&#125;<br><span class="hljs-comment">// 创建TreeMapper集合对象并指定比较器</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; comparator)</span> &#123;<br>    <span class="hljs-built_in">this</span>.comparator = comparator;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-TreeMap类的常用方法"><a href="#3-TreeMap类的常用方法" class="headerlink" title="3. TreeMap类的常用方法"></a>3. TreeMap类的常用方法</h4><ul>
<li><code>public V put(K key, V value)</code>:向集合中添加数据<ol>
<li>key:键值</li>
<li>value:值</li>
</ol>
</li>
<li><code>public void putAll(Map&lt;? extends K, ? extends V&gt; map)</code>:添加整个Map集合的数据</li>
<li><code>public V get(Object key)</code>:指定key获取集合中的value值</li>
<li><code>public K firstKey()</code>:获取集合中第一个元素的key</li>
<li><code>public K lastKey()</code>:获取集合中最后一个元素的key</li>
<li><code>public boolean containsKey(Object key)</code>:判断集合中是否包含指定key</li>
<li><code>public boolean containsValue(Object value)</code>:判断集合中是否包含指定value</li>
<li><code>public Set&lt;K&gt; keySet()</code>:取出集合中所有的key值</li>
<li><code>public Collection&lt;V&gt; values()</code>:取出集合中所有的value值</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>:取出集合中所有的key-value(取出键值对)</li>
<li><code>public V remove(Object key)</code>:指定key移除集合中的元素</li>
<li><code>public int size()</code>:获取集合中添加的元素数量</li>
<li><code>boolean isEmpty()</code>:获取集合是否为空</li>
<li><code>public void clear()</code>:清空集合中所有的元素</li>
</ul>
<h4 id="4-TreeMap集合代码案例"><a href="#4-TreeMap集合代码案例" class="headerlink" title="4. TreeMap集合代码案例"></a>4. TreeMap集合代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用多态方式创建TreeMap集合对象</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `public V put(K key, V value)`:向集合中添加数据</span><br>        <span class="hljs-comment">// 1. key:键值</span><br>        <span class="hljs-comment">// 2. value:值</span><br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>        map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;男神&quot;</span>);<br>        <span class="hljs-comment">// 赋值一个相同的</span><br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        System.out.println(map);<br>        <span class="hljs-comment">// 2. `public void putAll(Map&lt;? extends K, ? extends V&gt; map)`:添加整个Map集合的数据</span><br>        map.putAll(map);<br>        <span class="hljs-comment">// 3. `public V get(Object key)`:指定key获取集合中的value值</span><br>        System.out.println(map.get(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 一下两个方法是TreeMap私有方法所以需要向下转型</span><br>        TreeMap&lt;String, Object&gt; treeMap = (TreeMap&lt;String, Object&gt;) map;<br>        <span class="hljs-comment">// 4. `public K firstKey()`:获取集合中第一个元素的key</span><br>        System.out.println(treeMap.firstKey());<br>        <span class="hljs-comment">// 5. `public K lastKey()`:获取集合中最后一个元素的key</span><br>        System.out.println(treeMap.lastKey());<br>        <span class="hljs-comment">// 6. `public boolean containsKey(Object key)`:判断集合中是否包含指定key</span><br>        System.out.println(map.containsKey(<span class="hljs-string">&quot;name&quot;</span>));<br>        <span class="hljs-comment">// 7. `public boolean containsValue(Object value)`:判断集合中是否包含指定value</span><br>        System.out.println(map.containsValue(<span class="hljs-string">&quot;吴彦祖&quot;</span>));<br>        <span class="hljs-comment">// 8. `public Set&lt;K&gt; keySet()`:取出集合中所有的key值</span><br>        Set&lt;String&gt; strings = map.keySet();<br>        System.out.println(strings);<br>        <span class="hljs-comment">// 9. `public Collection&lt;V&gt; values()`:取出集合中所有的value值</span><br>        Collection&lt;Object&gt; values = map.values();<br>        System.out.println(values);<br>        <span class="hljs-comment">// 10. `public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()`:取出集合中所有的key-value(取出键值对)</span><br>        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = map.entrySet();<br>        System.out.println(entries);<br>        <span class="hljs-comment">// 11. `public V remove(Object key)`:指定key移除集合中的元素</span><br>        System.out.println(map.remove(<span class="hljs-string">&quot;sex&quot;</span>));<br>        <span class="hljs-comment">// 12. `public int size()`:获取集合中添加的元素数量</span><br>        System.out.println(map.size());<br>        <span class="hljs-comment">// 13. `boolean isEmpty()`:获取集合是否为空</span><br>        System.out.println(map.isEmpty());<br>        <span class="hljs-comment">// 14. `public void clear()`:清空集合中所有的元素</span><br>        map.clear();<br>        System.out.println(map.size());<br>        System.out.println(map.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><h4 id="1-Set接口概述"><a href="#1-Set接口概述" class="headerlink" title="1. Set接口概述"></a>1. Set接口概述</h4><blockquote>
<p>Set接口与List接口相同都是Collection接口的子孙接口,Set接口中没有新增方法(所有的方法都是他爹的Collection接口的),之前所用的List接口的方法在Set接口中也是通用的<br>Set接口特点:数据不重复,顺序是无序的(添加顺序与取出顺序不同,以及没有下标指向)无索引,遍历只能通过循环遍历(数据不能重复的原因是使用的HashMap类的put方法)</p>
</blockquote>
<h4 id="2-Set接口方法–-gt-与他父类Collection接口一致"><a href="#2-Set接口方法–-gt-与他父类Collection接口一致" class="headerlink" title="2. Set接口方法–&gt;与他父类Collection接口一致"></a>2. Set接口方法–&gt;与他父类Collection接口一致</h4><ul>
<li><code>boolean add(E e)</code>:向集合中添加元素</li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>:向集合中添加一个集合元素</li>
<li><code>boolean contains(Object o)</code>:检测集合中是否包含某个元素</li>
<li><code>boolean containsAll(Collection&lt;?&gt; c)</code>:检测集合中是否包含另一个集合中的元素</li>
<li><code>boolean remove(Object o)</code>:从集合中移除指定数据(对象)</li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code>:移除此集合的所有也包含在指定集合中的元素</li>
<li><code>boolean retainAll(Collection&lt;?&gt; c)</code>:移除刺激和的所有不包含在指定集合中的元素(移除非相同的元素,非交集元素)</li>
<li><code>int size()</code>:返回集合中的元素数量</li>
<li><code>boolean isEmpty()</code>:判断集合是否为空</li>
<li><code>Object[] toArray()</code>:将集合转为数组</li>
<li><code>void clear()</code>:清空集合内元素</li>
<li><code>Iterator&lt;E&gt; iterator()</code>:返回集合迭代器元素,用于遍历集合中的所有元素</li>
</ul>
<h3 id="Set接口之HashSet类"><a href="#Set接口之HashSet类" class="headerlink" title="Set接口之HashSet类"></a>Set接口之HashSet类</h3><h4 id="1-HashSet类概述"><a href="#1-HashSet类概述" class="headerlink" title="1. HashSet类概述"></a>1. HashSet类概述</h4><blockquote>
<p>HashSet底层使用哈希表算法实现,底层实际是使用<code>HashMap的put方法</code>实现,所以本质HashMap是HashSet类的母亲,HashSet有些类似于野孩子,谁的方法都有</p>
</blockquote>
<h4 id="2-HashSet类使用HashMap类的实现"><a href="#2-HashSet类使用HashMap类的实现" class="headerlink" title="2. HashSet类使用HashMap类的实现"></a>2. HashSet类使用HashMap类的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;<br>    <span class="hljs-comment">// 声明HashMap类对象,在创建HashSet对象时创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br>    <span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">// 创建HashSet对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 顺带着创建了HashMap集合对象</span><br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-HashSet类的构造方法"><a href="#3-HashSet类的构造方法" class="headerlink" title="3. HashSet类的构造方法"></a>3. HashSet类的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用空参构造方法创建HashSet集合对象,并在内部创建HashMap集合对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建HashMap集合对象</span><br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br><span class="hljs-comment">// 使用带参构造方法创建HashSet集合对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-comment">// 创建HashMap集合对象并初始化容量</span><br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-HashSet类的常用方法"><a href="#4-HashSet类的常用方法" class="headerlink" title="4. HashSet类的常用方法"></a>4. HashSet类的常用方法</h4><ul>
<li><code>public boolean add(E e)</code>:向集合中添加元素方法</li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>:向集合中添加指定集合的所有数据</li>
<li><code>public boolean contains(Object o)</code>:判断集合中是否包含某一个指定的元素</li>
<li><code>public boolean remove(Object o)</code>:从集合中移除指定元素,如果成功则返回true,否则返回false</li>
<li><code>public int size()</code>:返回集合中元素数量</li>
<li><code>public boolean isEmpty()</code>:判断集合是否为空</li>
<li><code>public Iterator&lt;E&gt; iterator()</code>:返回此集合的迭代器对象</li>
<li><code>public void clear()</code>:移除集合中所有的元素</li>
</ul>
<h4 id="5-HashSet类的代码案例"><a href="#5-HashSet类的代码案例" class="headerlink" title="5. HashSet类的代码案例"></a>5. HashSet类的代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建HashSet集合对象</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `public boolean add(E e)`:向集合中添加元素方法</span><br>        set.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;梅超风&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;灭绝师太&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;川建国&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;基尼太美&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;古校长&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(set);<br>        <span class="hljs-comment">// 2. `boolean addAll(Collection&lt;? extends E&gt; c)`:向集合中添加指定集合的所有数据</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;古校长&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;古天乐&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;渣渣辉&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;小泽老师&quot;</span>);<br>        set.addAll(list);<br>        System.out.println(set);<br>        <span class="hljs-comment">// 3. `public boolean contains(Object o)`:判断集合中是否包含某一个指定的元素</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;灭绝师太&quot;</span>));<br>        <span class="hljs-comment">// 4. `public boolean remove(Object o)`:从集合中移除指定元素,如果成功则返回true,否则返回false</span><br>        System.out.println(set.remove(<span class="hljs-string">&quot;基尼太美&quot;</span>));<br>        System.out.println(set.remove(<span class="hljs-string">&quot;基尼太美&quot;</span>));<br>        System.out.println(set);<br>        <span class="hljs-comment">// 5. `public int size()`:返回集合中元素数量</span><br>        System.out.println(set.size());<br>        <span class="hljs-comment">// 6. `public boolean isEmpty()`:判断集合是否为空</span><br>        System.out.println(set.isEmpty());<br>        System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>        <span class="hljs-comment">// 7. `public Iterator&lt;E&gt; iterator()`:返回此集合的迭代器对象</span><br>        Iterator&lt;String&gt; iterator = set.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>        <span class="hljs-comment">// 8. `public void clear()`:移除集合中所有的元素</span><br>        System.out.println(<span class="hljs-string">&quot;调用clear方法&quot;</span>);<br>        set.clear();<br>        System.out.println(set);<br>        System.out.println(set.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-HashSet中都是如何实现的方法"><a href="#6-HashSet中都是如何实现的方法" class="headerlink" title="6. HashSet中都是如何实现的方法"></a>6. HashSet中都是如何实现的方法</h4><blockquote>
<p>HashSet的方法没有一个是自己写的,要么是继承自AbstractSet抽象类,要么就是直接调用HashMap的方法</p>
</blockquote>
<h5 id="1-所以HashSet为什么不允许重复值就是因为调用的HashMap的put方法-而put放中有验证-hashCode和equals"><a href="#1-所以HashSet为什么不允许重复值就是因为调用的HashMap的put方法-而put放中有验证-hashCode和equals" class="headerlink" title="1. 所以HashSet为什么不允许重复值就是因为调用的HashMap的put方法,而put放中有验证(hashCode和equals)"></a>1. 所以HashSet为什么不允许重复值就是因为调用的HashMap的put方法,而put放中有验证(hashCode和equals)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 仅仅只是一个方法举例子,其他的相同!</span><br><span class="hljs-comment">// HashSet类中的add方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// HashSet什么事儿都没做直接调用map.put()设置值</span><br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="21-Set接口之TreeSet"><a href="#21-Set接口之TreeSet" class="headerlink" title="21. Set接口之TreeSet"></a>21. Set接口之TreeSet</h3><h4 id="1-TreeSet类的概述"><a href="#1-TreeSet类的概述" class="headerlink" title="1. TreeSet类的概述"></a>1. TreeSet类的概述</h4><blockquote>
<p>TreeSet底层实现是基于TreeMap类的,TreeMap与HashSet相同,没有自己独立的方法,所以本质也是数组TreeMap类</p>
</blockquote>
<h4 id="2-TreeSet类的构造方法"><a href="#2-TreeSet类的构造方法" class="headerlink" title="2. TreeSet类的构造方法"></a>2. TreeSet类的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用空参构造方法创建TreeSet对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用带参构造方法创建一个TreeMap对象</span><br>    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;E,Object&gt;());<br>&#125;<br><span class="hljs-comment">// 使用指定collection集合创建TreeSet对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 调用空参构造方法</span><br>    <span class="hljs-built_in">this</span>();<br>    <span class="hljs-comment">// 调用addAll方法添加集合</span><br>    addAll(c);<br>&#125;<br><span class="hljs-comment">// 创建带有比较器的TreeSet对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(comparator));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-TreeSet类的常用方法"><a href="#3-TreeSet类的常用方法" class="headerlink" title="3. TreeSet类的常用方法"></a>3. TreeSet类的常用方法</h4><ul>
<li><code>public boolean add(E e)</code>:向集合中添加元素方法</li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>:向集合中添加指定集合的所有数据</li>
<li><code>public boolean contains(Object o)</code>:判断集合中是否包含某一个指定的元素</li>
<li><code>public boolean remove(Object o)</code>:从集合中移除指定元素,如果成功则返回true,否则返回false</li>
<li><code>public int size()</code>:返回集合中元素数量</li>
<li><code>public boolean isEmpty()</code>:判断集合是否为空</li>
<li><code>public Iterator&lt;E&gt; iterator()</code>:返回此集合的迭代器对象</li>
<li><code>public void clear()</code>:移除集合中所有的元素</li>
</ul>
<h4 id="4-TreeSet类的代码案例"><a href="#4-TreeSet类的代码案例" class="headerlink" title="4. TreeSet类的代码案例"></a>4. TreeSet类的代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用多态方式创建TreeSet集合</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `public boolean add(E e)`:向集合中添加元素方法</span><br>        set.add(<span class="hljs-string">&quot;蜘蛛侠&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;黑寡妇&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;绿巨人&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;美国翘臀&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;死侍&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;死侍&quot;</span>);<br>        System.out.println(set);<br>        <span class="hljs-comment">// 2. `boolean addAll(Collection&lt;? extends E&gt; c)`:向集合中添加指定集合的所有数据</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;超人&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;蝙蝠侠&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;钢骨&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;神奇女侠&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;海王&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;海王&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;火星猎人&quot;</span>);<br>        System.out.println(list);<br>        set.addAll(list);<br>        System.out.println(set);<br>        <span class="hljs-comment">// 3. `public boolean contains(Object o)`:判断集合中是否包含某一个指定的元素</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;黑寡妇&quot;</span>));<br>        <span class="hljs-comment">// 4. `public boolean remove(Object o)`:从集合中移除指定元素,如果成功则返回true,否则返回false</span><br>        System.out.println(set.remove(<span class="hljs-string">&quot;火星猎人&quot;</span>));<br>        System.out.println(set.remove(<span class="hljs-string">&quot;火星猎人&quot;</span>));<br>        System.out.println(set);<br>        <span class="hljs-comment">// 5. `public int size()`:返回集合中元素数量</span><br>        System.out.println(set.size());<br>        <span class="hljs-comment">// 6. `public boolean isEmpty()`:判断集合是否为空</span><br>        System.out.println(set.isEmpty());<br>        <span class="hljs-comment">// 7. `public Iterator&lt;E&gt; iterator()`:返回此集合的迭代器对象</span><br>        System.out.println(<span class="hljs-string">&quot;==========================================&quot;</span>);<br>        Iterator&lt;String&gt; iterator = set.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>        <span class="hljs-comment">// 8. `public void clear()`:移除集合中所有的元素</span><br>        System.out.println(<span class="hljs-string">&quot;调用clear方法&quot;</span>);<br>        set.clear();<br>        System.out.println(set);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-TreeSet类的具体实现"><a href="#5-TreeSet类的具体实现" class="headerlink" title="5. TreeSet类的具体实现"></a>5. TreeSet类的具体实现</h4><blockquote>
<p>TreeSet与HashSet相同没有自己的实现,TreeSet所有的方法都是调用TreeMap的方法</p>
</blockquote>
<h5 id="1-TreeSet类的add方法实现"><a href="#1-TreeSet类的add方法实现" class="headerlink" title="1. TreeSet类的add方法实现"></a>1. TreeSet类的add方法实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// map集合</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br><span class="hljs-comment">// 通过构造方法创建TreeMap集合对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;E,Object&gt;());<br>&#125;<br><span class="hljs-comment">// TreeSet集合的add方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 调用TreeMap集合的put方法</span><br>    <span class="hljs-keyword">return</span> m.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Set接口之LinkedHashSet类"><a href="#Set接口之LinkedHashSet类" class="headerlink" title="Set接口之LinkedHashSet类"></a>Set接口之LinkedHashSet类</h3><h4 id="1-LinkedHashSet类概述"><a href="#1-LinkedHashSet类概述" class="headerlink" title="1. LinkedHashSet类概述"></a>1. LinkedHashSet类概述</h4><blockquote>
<p>LinkedHashSet类没有自己的方法所用的是继承HashSet的方法,所有使用的方法也都是基于HashSet类而HashSet类中创建对象有两个,一个是HashMap一个LinkedHashMap,而其中LinkedHashMap是供LinkedHashSet使用,LinkedHashSet集合是有序的(存储顺序与调用顺序一致)</p>
</blockquote>
<h4 id="2-LinkedHashSet类的构造方法"><a href="#2-LinkedHashSet类的构造方法" class="headerlink" title="2. LinkedHashSet类的构造方法"></a>2. LinkedHashSet类的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用空参构造方法创建LinkedHashSet对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 调用其父HashSet构造方法创建LinkedHashMap对象,使用LinkedHashMap方法</span><br>    <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>, <span class="hljs-number">.75f</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-comment">// 使用指定初始化容量的构造方法创建LinkedHashSet对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedHashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-comment">// 调用其父HashSet构造方法创建LinkedHashMap对象,使用LinkedHashMap方法</span><br>    <span class="hljs-built_in">super</span>(initialCapacity, <span class="hljs-number">.75f</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-LinkedHashSet类的构造方法"><a href="#3-LinkedHashSet类的构造方法" class="headerlink" title="3. LinkedHashSet类的构造方法"></a>3. LinkedHashSet类的构造方法</h4><ul>
<li><code>public boolean add(E e)</code>:向集合中添加元素方法</li>
<li><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>:向集合中添加指定集合的所有数据</li>
<li><code>public boolean contains(Object o)</code>:判断集合中是否包含某一个指定的元素</li>
<li><code>public boolean remove(Object o)</code>:从集合中移除指定元素,如果成功则返回true,否则返回false</li>
<li><code>public int size()</code>:返回集合中元素数量</li>
<li><code>public boolean isEmpty()</code>:判断集合是否为空</li>
<li><code>public Iterator&lt;E&gt; iterator()</code>:返回此集合的迭代器对象</li>
<li><code>public void clear()</code>:移除集合中所有的元素</li>
</ul>
<h4 id="4-LinkedHashSet类的代码案例"><a href="#4-LinkedHashSet类的代码案例" class="headerlink" title="4. LinkedHashSet类的代码案例"></a>4. LinkedHashSet类的代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedHashSetDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建LinkedHashSet集合对象</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 1. `public boolean add(E e)`:向集合中添加元素方法</span><br>        set.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;吴彦祖&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;梅超风&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;灭绝师太&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;川建国&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;基尼太美&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;古校长&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        System.out.println(set);<br>        <span class="hljs-comment">// 2. `boolean addAll(Collection&lt;? extends E&gt; c)`:向集合中添加指定集合的所有数据</span><br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;彭于晏&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;古校长&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;古天乐&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;渣渣辉&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;小泽老师&quot;</span>);<br>        set.addAll(list);<br>        System.out.println(set);<br>        <span class="hljs-comment">// 3. `public boolean contains(Object o)`:判断集合中是否包含某一个指定的元素</span><br>        System.out.println(set.contains(<span class="hljs-string">&quot;灭绝师太&quot;</span>));<br>        <span class="hljs-comment">// 4. `public boolean remove(Object o)`:从集合中移除指定元素,如果成功则返回true,否则返回false</span><br>        System.out.println(set.remove(<span class="hljs-string">&quot;基尼太美&quot;</span>));<br>        System.out.println(set.remove(<span class="hljs-string">&quot;基尼太美&quot;</span>));<br>        System.out.println(set);<br>        <span class="hljs-comment">// 5. `public int size()`:返回集合中元素数量</span><br>        System.out.println(set.size());<br>        <span class="hljs-comment">// 6. `public boolean isEmpty()`:判断集合是否为空</span><br>        System.out.println(set.isEmpty());<br>        System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>        <span class="hljs-comment">// 7. `public Iterator&lt;E&gt; iterator()`:返回此集合的迭代器对象</span><br>        Iterator&lt;String&gt; iterator = set.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>        <span class="hljs-comment">// 8. `public void clear()`:移除集合中所有的元素</span><br>        System.out.println(<span class="hljs-string">&quot;调用clear方法&quot;</span>);<br>        set.clear();<br>        System.out.println(set);<br>        System.out.println(set.isEmpty());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="集合中的Comparator比较器"><a href="#集合中的Comparator比较器" class="headerlink" title="集合中的Comparator比较器"></a>集合中的Comparator比较器</h3><h4 id="1-Comparator比较器概述"><a href="#1-Comparator比较器概述" class="headerlink" title="1. Comparator比较器概述"></a>1. Comparator比较器概述</h4><blockquote>
<p> Comparator比较器作用是用于集合的自定义排序,排序规则分为两种,1. 升序;2. 降序;<br> <code>注意:集合的构造方法中带有Comparator比较器参数就代表,给其添加元素时元素必须要有实现Comparator比较器,或者使用外部比较器实现</code></p>
</blockquote>
<h4 id="2-使用Set集合的比较器案例"><a href="#2-使用Set集合的比较器案例" class="headerlink" title="2. 使用Set集合的比较器案例"></a>2. 使用Set集合的比较器案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 调用Set集合的比较实现</span><br>        func01();<br>    &#125;<br>    <span class="hljs-comment">// Set集合的比较</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用TreeSet的比较器构造方法创建对象,其中Comparator比较器使用外部比较器</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 比较方法</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> o1 字符串1</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> o2 字符串2</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@return</span> 返回字符串1与字符串2的对比</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1.compareTo(o2);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 1. `public boolean add(E e)`:向集合中添加元素方法</span><br>        set.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;2&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;4&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-comment">// [死侍, 绿巨人, 美国翘臀, 蜘蛛侠, 黑寡妇]</span><br>        <span class="hljs-comment">// [黑寡妇, 蜘蛛侠, 美国翘臀, 绿巨人, 死侍]</span><br>        System.out.println(set);<br>        <span class="hljs-comment">// 使用自定义对象创建外部比较器的TreeSet集合对象</span><br>        Set&lt;Person&gt; persons1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>                <span class="hljs-comment">// 使用年龄排序</span><br>                <span class="hljs-comment">// return o2.getAge() - o1.getAge();</span><br>                <span class="hljs-comment">// 按照名称排序</span><br>                <span class="hljs-comment">// return o1.getName().compareTo(o2.getName());</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">o1Name</span> <span class="hljs-operator">=</span> o1.getName();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">o1Sex</span> <span class="hljs-operator">=</span> o1.getSex();<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">o1Age</span> <span class="hljs-operator">=</span> o1.getAge();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">o2Name</span> <span class="hljs-operator">=</span> o2.getName();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">o2Sex</span> <span class="hljs-operator">=</span> o2.getSex();<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">o2Age</span> <span class="hljs-operator">=</span> o2.getAge();<br>                <span class="hljs-comment">// 将所有的值相加然后使用String类的compareTo方法</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">personString1</span> <span class="hljs-operator">=</span> o1Name + o1Sex + o1Age;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">personString2</span> <span class="hljs-operator">=</span> o2Name + o2Sex + o2Age;<br>                <span class="hljs-keyword">return</span> personString1.compareTo(personString2);<br>            &#125;<br>        &#125;);<br>        persons1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">1000</span>));<br>        persons1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">900</span>));<br>        persons1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;沙悟净&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">800</span>));<br>        persons1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白龙马&quot;</span>, <span class="hljs-string">&quot;龙&quot;</span>, <span class="hljs-number">200</span>));<br>        persons1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;唐玄奘&quot;</span>, <span class="hljs-string">&quot;人&quot;</span>, <span class="hljs-number">500</span>));<br>        persons1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白骨精&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">300</span>));<br>        System.out.println(persons1);<br>        <span class="hljs-comment">// 使用Person自定义对象创建内部比较器,进行比较,所有的带有比较器的集合添加的数据都必须实现比较器接口</span><br>        <span class="hljs-comment">// 如果Person没有实现比较器并且没有使用外部比较器则无法直接添加到TreeSet集合中</span><br>        Set&lt;Person&gt; persons2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        persons2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">1000</span>));<br>        persons2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">900</span>));<br>        persons2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;沙悟净&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">800</span>));<br>        persons2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白龙马&quot;</span>, <span class="hljs-string">&quot;龙&quot;</span>, <span class="hljs-number">200</span>));<br>        persons2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;唐玄奘&quot;</span>, <span class="hljs-string">&quot;人&quot;</span>, <span class="hljs-number">500</span>));<br>        persons2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白骨精&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">300</span>));<br>        System.out.println(persons2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-使用List集合的比较器案例"><a href="#3-使用List集合的比较器案例" class="headerlink" title="3. 使用List集合的比较器案例"></a>3. 使用List集合的比较器案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 调用List集合的比较实现</span><br>        func02();<br>    &#125;<br>    <span class="hljs-comment">// List集合的比较</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func02</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现List结合的比较方法sort</span><br>        List&lt;Person&gt; persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">1000</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">900</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;沙悟净&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">800</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白龙马&quot;</span>, <span class="hljs-string">&quot;龙&quot;</span>, <span class="hljs-number">200</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;唐玄奘&quot;</span>, <span class="hljs-string">&quot;人&quot;</span>, <span class="hljs-number">500</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白骨精&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">300</span>));<br>        System.out.println(persons);<br>        <span class="hljs-comment">// 调用sort排序方法</span><br>        persons.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 输出结果</span><br>        System.out.println(persons);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="HashMap与HashSet集合中添加自定义对象重复原因"><a href="#HashMap与HashSet集合中添加自定义对象重复原因" class="headerlink" title="HashMap与HashSet集合中添加自定义对象重复原因"></a>HashMap与HashSet集合中添加自定义对象重复原因</h3><h4 id="1-数据重复的原因"><a href="#1-数据重复的原因" class="headerlink" title="1. 数据重复的原因"></a>1. 数据重复的原因</h4><blockquote>
<p>已知HashMap的Key和HashSet集合中不能添加重复数据,而我们自定义对象却可以重复,其根本原因是Map中的put方法验证Key是否重复使用的是hashCode和equals方法验证,而自定义类在不重写的情况下使用的是父类Object类的方法,所以计算的结果都不同,也就导致了添加时会重复的原因,一旦重写hashCode和equals方法后则不会出现此问题</p>
</blockquote>
<h4 id="2-解决数据重复"><a href="#2-解决数据重复" class="headerlink" title="2. 解决数据重复"></a>2. 解决数据重复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt; &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, String sex, Integer age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现Comparable接口重写compareTo方法实现排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 传入的Person对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回计算的结果(整数类型)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person o)</span> &#123;<br>        <span class="hljs-comment">// 使用年龄排序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - o.age;<br>    &#125;<br><br>    <span class="hljs-comment">// 重写equals</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;<br>        <span class="hljs-keyword">return</span> Objects.equals(name, person.name) &amp;&amp; Objects.equals(sex, person.sex) &amp;&amp; Objects.equals(age, person.age);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写hashCode</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, sex, age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizeObjectDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 使用自定义对象,向Set集合中添加数据</span><br>        <span class="hljs-comment">// 会出现数据重复的问题,其原因是因为map中的put方法比较时是使用hashCode和equals方法去判断的</span><br>        Set&lt;Person&gt; persons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置数据</span><br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">1000</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">900</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;沙悟净&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">800</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白龙马&quot;</span>, <span class="hljs-string">&quot;龙&quot;</span>, <span class="hljs-number">200</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;唐玄奘&quot;</span>, <span class="hljs-string">&quot;人&quot;</span>, <span class="hljs-number">500</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白骨精&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">300</span>));<br>        <span class="hljs-comment">// 添加重复数据</span><br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">1000</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">900</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;沙悟净&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">800</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白龙马&quot;</span>, <span class="hljs-string">&quot;龙&quot;</span>, <span class="hljs-number">200</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;唐玄奘&quot;</span>, <span class="hljs-string">&quot;人&quot;</span>, <span class="hljs-number">500</span>));<br>        persons.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;白骨精&quot;</span>, <span class="hljs-string">&quot;妖&quot;</span>, <span class="hljs-number">300</span>));<br>        <span class="hljs-comment">// 使用迭代器打印数据</span><br>        Iterator&lt;Person&gt; iterator = persons.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            System.out.println(iterator.next());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h3><h4 id="1-Collections是Java提供的操作集合的工具类-也是一个鸡肋产品-提供了部分的集合方法-例如排序等等"><a href="#1-Collections是Java提供的操作集合的工具类-也是一个鸡肋产品-提供了部分的集合方法-例如排序等等" class="headerlink" title="1. Collections是Java提供的操作集合的工具类,也是一个鸡肋产品,提供了部分的集合方法,例如排序等等"></a>1. Collections是Java提供的操作集合的工具类,也是一个鸡肋产品,提供了部分的集合方法,例如排序等等</h4><h4 id="2-Collections中的方法"><a href="#2-Collections中的方法" class="headerlink" title="2. Collections中的方法"></a>2. Collections中的方法</h4><ul>
<li><code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>:排序方法,默认升序并且无法更改降序</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>:升序加降序都可以的</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>:混乱排序</li>
<li><code>public static void reverse(List&lt;?&gt; list)</code>:将集合倒转</li>
</ul>
<h4 id="3-Collections代码案例"><a href="#3-Collections代码案例" class="headerlink" title="3. Collections代码案例"></a>3. Collections代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionsDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;超人&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;蝙蝠侠&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;钢骨&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;神奇女侠&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;海王&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;海王&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;火星猎人&quot;</span>);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 1. `public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)`:排序方法,默认升序并且无法更改降序</span><br>        Collections.sort(list);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 2. `public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)`:升序加降序都可以的</span><br>        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String o1, String o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>            &#125;<br>        &#125;);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 3. `public static void shuffle(List&lt;?&gt; list)`:混乱排序</span><br>        Collections.shuffle(list);<br>        System.out.println(list);<br>        <span class="hljs-comment">// 4. `public static void reverse(List&lt;?&gt; list)`:将集合倒转</span><br>        Collections.sort(list);<br>        System.out.println(list);<br>        Collections.reverse(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<div>
<hr>
<script src="https://unpkg.com/@waline/client@v2/dist/waline.js"></script> 
<link
  rel="stylesheet"
  href="https://unpkg.com/@waline/client@v2/dist/waline.css"
/>
<div id="waline"></div>
  <script>
    Waline({
      el: '#waline',
      serverURL: 'https://vercel-project-4d7haxk1c-i-xiaoxin.vercel.app',
    });
  </script>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java集合体系</div>
      <div>https://github.com/i-xiaoxin/2022/09/21/java集合体系/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>xiaoxinlore</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/21/%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%BF%E7%94%A8Demo/" title="七牛云使用Demo">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">七牛云使用Demo</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/21/Hexo%20Fluid%20%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3%E6%8C%87%E5%8D%97/" title="Hexo Fluid 使用相关指南">
                        <span class="hidden-mobile">Hexo Fluid 使用相关指南</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.6.3/waline.min.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.6.3/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://vercel-project-4d7haxk1c-i-xiaoxin.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
